[
  {
    "objectID": "startup.html",
    "href": "startup.html",
    "title": "bayesTPC: An accessible interface to fit Bayesian thermal performance curves in R.",
    "section": "",
    "text": "bayesTPC is an R package to help conveniently fit common thermal performance models using Bayesian MCMC. We provide functionality to substitute for or supplement BUGS modelling workflows, especially for those without experience in Bayesian methods. To this end, bayesTPC contains a simple model specification format, BUGS configuration helpers, end-to-end model fitting methods, and model diagnostics.\n\n\nYou can install the development version of bayesTPC from GitHub with:\nremotes::install_github(\"johnwilliamsmithjr/bayesTPC\")\n\n\n\n\n\nbayesTPC offers many pre-configured TPC models. We can use get_models() to view all implemented models.\n\nget_models()\n#&gt;  [1] \"poisson_glm_lin\"    \"poisson_glm_quad\"   \"binomial_glm_lin\"  \n#&gt;  [4] \"binomial_glm_quad\"  \"bernoulli_glm_lin\"  \"bernoulli_glm_quad\"\n#&gt;  [7] \"briere\"             \"gaussian\"           \"kamykowski\"        \n#&gt; [10] \"pawar_shsch\"        \"quadratic\"          \"ratkowsky\"         \n#&gt; [13] \"stinner\"            \"weibull\"\n\nTo see the exact specification of a particular model, we can use\n\nget_default_model_specification(\"briere\")\n#&gt; bayesTPC Model Specification of Type:\n#&gt;   briere\n#&gt; \n#&gt; Model Formula:\n#&gt;   m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n#&gt; * (T_max &gt; Temp) * (Temp &gt; T_min) )\n#&gt; \n#&gt; Model Distribution:\n#&gt;   Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n#&gt; \n#&gt; Model Parameters and Priors:\n#&gt;   q ~ dexp(1)\n#&gt;   T_max ~ dunif(25, 60)\n#&gt;   T_min ~ dunif(0, 20)\n#&gt;   sigma.sq ~ dexp(1)\n\nUse get_formula(), get_default_priors(), and get_default_constants() to display the individual components of a any model included in bayesTPC.\nFor those with experience in fitting models in BUGS, configure_model() provides pre-formatted code.\n\n\n\nThe fitting workhorse of bayesTPC is the b_TPC() function. With b_TPC(), a user only needs to specify the dataset and desired model and bayesTPC handles configuring and running an MCMC using nimble. The user can also change the model priors, the sampler used, and other hyperparameters of the MCMC.\n\n\n\nOne can also create their own models by specifying a formula and priors using specify_model(), along with its wrappers specify_normal_model() and specify_binomial_model().\nbayesTPC accepts both the name of a model and the model object itself as inputs to its workhorse functions. This provides two methods for users to customize existing models: providing customized priors and constants in the options of the functions themselves, or by storing the model object in the local environment and using the change_priors() and change_constants() functions. Note that since R objects are immutable, the modified models must be stored again.\n\n\n\nThe fit object returned by b_TPC() can be summarized in multiple ways. summary() gives a detailed summary of the MCMC results, and plot() shows the fit given by the center (mean or median) and bounding (95% quantiles or hdi) MCMC samples. Similarly, posterior_predictive() and plot_prediction() take samples of the posterior to predict new values.\n\n\n\nbayesTPC provides multiple MCMC diagnostic plots. traceplot() wraps coda::traceplot() and shows the sampled values by sequential iteration. bayesTPC_ipairs() wraps IDPmisc::ipairs() and shows the pairwise joint posterior distributions of all model parameters. These wrappers are provided for convenience.\nThe ppo_plot() function shows the overlap between the priors specified versus a kernel density estimation of the posterior sample.\n\n\n\nbayesTPC also includes a basic API to access the Vectraits database of disease vector trait data. One can either retrieve a pre-known dataset using get_VB_dataset() or get_VB_datasets(), or search specific keywords using find_VB_datasets()."
  },
  {
    "objectID": "startup.html#installation",
    "href": "startup.html#installation",
    "title": "bayesTPC: An accessible interface to fit Bayesian thermal performance curves in R.",
    "section": "",
    "text": "You can install the development version of bayesTPC from GitHub with:\nremotes::install_github(\"johnwilliamsmithjr/bayesTPC\")"
  },
  {
    "objectID": "startup.html#functionality",
    "href": "startup.html#functionality",
    "title": "bayesTPC: An accessible interface to fit Bayesian thermal performance curves in R.",
    "section": "",
    "text": "bayesTPC offers many pre-configured TPC models. We can use get_models() to view all implemented models.\n\nget_models()\n#&gt;  [1] \"poisson_glm_lin\"    \"poisson_glm_quad\"   \"binomial_glm_lin\"  \n#&gt;  [4] \"binomial_glm_quad\"  \"bernoulli_glm_lin\"  \"bernoulli_glm_quad\"\n#&gt;  [7] \"briere\"             \"gaussian\"           \"kamykowski\"        \n#&gt; [10] \"pawar_shsch\"        \"quadratic\"          \"ratkowsky\"         \n#&gt; [13] \"stinner\"            \"weibull\"\n\nTo see the exact specification of a particular model, we can use\n\nget_default_model_specification(\"briere\")\n#&gt; bayesTPC Model Specification of Type:\n#&gt;   briere\n#&gt; \n#&gt; Model Formula:\n#&gt;   m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n#&gt; * (T_max &gt; Temp) * (Temp &gt; T_min) )\n#&gt; \n#&gt; Model Distribution:\n#&gt;   Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n#&gt; \n#&gt; Model Parameters and Priors:\n#&gt;   q ~ dexp(1)\n#&gt;   T_max ~ dunif(25, 60)\n#&gt;   T_min ~ dunif(0, 20)\n#&gt;   sigma.sq ~ dexp(1)\n\nUse get_formula(), get_default_priors(), and get_default_constants() to display the individual components of a any model included in bayesTPC.\nFor those with experience in fitting models in BUGS, configure_model() provides pre-formatted code.\n\n\n\nThe fitting workhorse of bayesTPC is the b_TPC() function. With b_TPC(), a user only needs to specify the dataset and desired model and bayesTPC handles configuring and running an MCMC using nimble. The user can also change the model priors, the sampler used, and other hyperparameters of the MCMC.\n\n\n\nOne can also create their own models by specifying a formula and priors using specify_model(), along with its wrappers specify_normal_model() and specify_binomial_model().\nbayesTPC accepts both the name of a model and the model object itself as inputs to its workhorse functions. This provides two methods for users to customize existing models: providing customized priors and constants in the options of the functions themselves, or by storing the model object in the local environment and using the change_priors() and change_constants() functions. Note that since R objects are immutable, the modified models must be stored again.\n\n\n\nThe fit object returned by b_TPC() can be summarized in multiple ways. summary() gives a detailed summary of the MCMC results, and plot() shows the fit given by the center (mean or median) and bounding (95% quantiles or hdi) MCMC samples. Similarly, posterior_predictive() and plot_prediction() take samples of the posterior to predict new values.\n\n\n\nbayesTPC provides multiple MCMC diagnostic plots. traceplot() wraps coda::traceplot() and shows the sampled values by sequential iteration. bayesTPC_ipairs() wraps IDPmisc::ipairs() and shows the pairwise joint posterior distributions of all model parameters. These wrappers are provided for convenience.\nThe ppo_plot() function shows the overlap between the priors specified versus a kernel density estimation of the posterior sample.\n\n\n\nbayesTPC also includes a basic API to access the Vectraits database of disease vector trait data. One can either retrieve a pre-known dataset using get_VB_dataset() or get_VB_datasets(), or search specific keywords using find_VB_datasets()."
  },
  {
    "objectID": "VB_Bayes_activity2B.html",
    "href": "VB_Bayes_activity2B.html",
    "title": "Introduction to Bayesian Methods",
    "section": "",
    "text": "This section is focused on using the bayesTPC package to fit TPCs to data using the methods we’ve explored in the Bayesian lectures and the first two activities. Here we won’t be talking much about the implementation, but instead will rely on the bayesTPC package and it’s functions to allow us to specify, fit, and analyze the data.\n\n\nFor this practical you will need to first install nimble, then be sure to install the following packages:\n\n# Load libraries\nlibrary(nimble)\nlibrary(HDInterval)\nlibrary(MCMCvis)\nlibrary(coda) # makes diagnostic plots\nlibrary(IDPmisc) # makes nice colored pairs plots to look at joint posteriors\nlibrary(matrixStats)\nlibrary(truncnorm)\n##library(mcmcplots) # another option for diagnostic plots, currently unused\n\n We are also introducing our new, in development, package bayesTPC. It is currently available through github.\n\n#install.packages(\"devtools\")\n#devtools::install_github(\"johnwilliamsmithjr/bayesTPC\")\nlibrary(bayesTPC)"
  },
  {
    "objectID": "VB_Bayes_activity2B.html#packages-and-tools",
    "href": "VB_Bayes_activity2B.html#packages-and-tools",
    "title": "Introduction to Bayesian Methods",
    "section": "",
    "text": "For this practical you will need to first install nimble, then be sure to install the following packages:\n\n# Load libraries\nlibrary(nimble)\nlibrary(HDInterval)\nlibrary(MCMCvis)\nlibrary(coda) # makes diagnostic plots\nlibrary(IDPmisc) # makes nice colored pairs plots to look at joint posteriors\nlibrary(matrixStats)\nlibrary(truncnorm)\n##library(mcmcplots) # another option for diagnostic plots, currently unused\n\n We are also introducing our new, in development, package bayesTPC. It is currently available through github.\n\n#install.packages(\"devtools\")\n#devtools::install_github(\"johnwilliamsmithjr/bayesTPC\")\nlibrary(bayesTPC)"
  },
  {
    "objectID": "VB_Bayes_activity2B.html#the-data",
    "href": "VB_Bayes_activity2B.html#the-data",
    "title": "Introduction to Bayesian Methods",
    "section": "The Data",
    "text": "The Data\nThese data are traits from Aedes aegypti mosquitoes measured across temperature in lab experiments. The traits we have data on thermal performance are:   - pEA: proportion surviving from egg to adulthood\n- MDR: mosquito development rate\n- PDR: parasite development rate (= 1/EIP the extrinsic incubation period)\n- \\mu (mu): death rate (here = 1/longevity)\nNote that some of the traits come in multiple forms (e.g., \\mu and 1/\\mu, PDR and EIP, if we’re assuming lifespan and development time are exponentially distributed – a common modeling assumption).\nAs always, first we have a look at the data:\n\nhead(Aaeg.data)\n\n  trait.name Temp   trait                   ref trait2 trait2.name\n1        pEA   22 0.90812 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n2        pEA   27 0.93590 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n3        pEA   32 0.81944 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n4        MDR   22 0.09174 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n5        MDR   27 0.13587 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n6        MDR   32 0.15823 Westbrook_Thesis_2010   &lt;NA&gt;        &lt;NA&gt;\n\n\nNow let’s pull a subset of the data related to mortality/survival:\n\nmu.data &lt;- subset(Aaeg.data, trait.name == \"mu\")\nlf.data &lt;- subset(Aaeg.data, trait.name == \"1/mu\")\npar(mfrow=c(1,2), bty=\"l\") \nplot(trait ~ Temp, data = mu.data, ylab=\"mu\")\nplot(trait ~ Temp, data = lf.data, ylab=\"1/mu\")\n\n\n\n\n\n\n\n\nNote that the \\mu data is u-shaped and the lifespan data is hump-shaped.\nWe could choose to fit this either way. Since thermal performance metrics are often assumed to be unimodal thermal responses, we will fit lifespan instead of \\mu as our example. Thus, we’ll need to convert the \\mu data to lifespan by taking the inverse. We will combine the data, by assuming that lifespan is 1/\\mu (not usually a good idea, but we’re going to do it here so we have more data for the example).\n\nmu.data.inv &lt;- mu.data # make a copy of the mu data\nmu.data.inv$trait &lt;- 1/mu.data$trait # take the inverse of the trait values to convert mu to lifespan\nlf.data.comb &lt;- rbind(mu.data.inv, lf.data) # combine both lifespan data sets together \npar(mfrow=c(1,1), bty=\"l\") \nplot(trait ~ Temp, data = lf.data.comb, ylab=\"1/mu\",\n     ylim=c(0,40))"
  },
  {
    "objectID": "VB_Bayes_activity2B.html#two-thermal-performance-curve-models",
    "href": "VB_Bayes_activity2B.html#two-thermal-performance-curve-models",
    "title": "Introduction to Bayesian Methods",
    "section": "Two thermal performance curve models",
    "text": "Two thermal performance curve models\nAlthough there are many functional forms that can be used to describe TPCs, we’ll focus on two of the more common (and easy to fit) functions. Traits that respond unimodally but symmetrically to temperature (often the case for compound traits) can be fit with a quadratic function: f_1(T) = \\begin{cases} 0 &\\text {if } T \\leq T_0 \\\\\n-q (T-T_0) (T-T_m) & \\text {if } T_0 &lt; T &lt;T_m \\\\\n0 &\\text{if } T \\geq T_m \\end{cases}\nTraits that respond unimodally but asymetrically can be fited with a Briere function: \nf_2(T) = \\begin{cases} 0 &\\text {if } T \\leq T_0 \\\\\nq T (T-T_0) \\sqrt{T_m-T} & \\text {if } T_0 &lt; T &lt;T_m \\\\\n0 &\\text{if } T \\geq T_m \\end{cases}\nIn both models, T_0 is the lower thermal limit, T_m is the upper thermal limit (i.e., where the trait value goes to zero on either end), and q&gt;0 scales the height of the curve, (and so also the value of the trait at the optimum temperature). Note that above we’re assuming that the quadratic must be concave down (hence the negative sign), and that the performance goes to zero outside of the thermal limits."
  },
  {
    "objectID": "VB_Bayes_activity2B.html#model-and-data-specification",
    "href": "VB_Bayes_activity2B.html#model-and-data-specification",
    "title": "Introduction to Bayesian Methods",
    "section": "Model and data specification",
    "text": "Model and data specification\nUnlike the previous Bayesian example, bayesTPC has a number of TPCs already implemented. We can view which TPC models are currently implemented:\n\nget_models()\n\n [1] \"poisson_glm_lin\"    \"poisson_glm_quad\"   \"binomial_glm_lin\"  \n [4] \"binomial_glm_quad\"  \"bernoulli_glm_lin\"  \"bernoulli_glm_quad\"\n [7] \"briere\"             \"gaussian\"           \"kamykowski\"        \n[10] \"pawar_shsch\"        \"quadratic\"          \"ratkowsky\"         \n[13] \"stinner\"            \"weibull\"           \n\n\nWe can view the form of the implemented TPC using the get_formula function:\n\nget_formula(\"quadratic\")\n\nexpression(-1 * q * (Temp - T_min) * (Temp - T_max) * (T_max &gt; \n    Temp) * (Temp &gt; T_min))\n\n\nCurrently, the likelihood for all TPCs is by default is a normal distribution with a lower truncation at zero, and where the mean of the normal distribution is set to be the TPC (here a quadratic). The last piece of the Bayesian puzzle is the prior. You can see the default parameter names and their default priors using “get_default_priors”:\n\nget_default_priors(\"quadratic\")\n\n               q            T_max            T_min         sigma.sq \n       \"dexp(1)\"  \"dunif(25, 60)\" \"dunif(-10, 20)\"        \"dexp(1)\" \n\n\nAs you can see, for the quadratic function, the default priors are specified via uniform distributions (the two arguments specific the lower and upper bounds, respectively). For the quadratic (and the Briere), the curvature parameter must be positive, and the priors need to be specified to ensure that T_{min}&lt;T_{max}. Note that if you want to set a prior to a normal distribution, unlike in R and most other programs, in nimble (and thus bayesTPC) the inverse of the variance of the normal distribution is used, denoted by \\tau = \\frac{1}{\\sigma^2}.\nbayesTPC expects data to be in a named list with the “Trait” as the response and “Temp” as the predictor, that is:\n\nlf.data.bTPC&lt;-list(Trait = lf.data.comb$trait, Temp=lf.data.comb$Temp)\n\nThe workhorse of the bayesTPC package is the b_TPC function. If you are happy to use the default priors, etc, the usage is simply:\n\nlibrary(bayesTPC)\nlibrary(nimble)\nAedTestFit&lt;- b_TPC(data = lf.data.bTPC, model = 'quadratic')\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n We can examine the object that is saved. It includes the data, information on the priors, numbers of samples, and the samples themselves.\n\nnames(AedTestFit)\n\n[1] \"samples\"        \"mcmc\"           \"data\"           \"model_spec\"    \n[5] \"priors\"         \"constants\"      \"uncomp_model\"   \"comp_model\"    \n[9] \"MAP_parameters\"\n\n\n We’ll mostly be using the samples:\n\ndim(AedTestFit$samples) # number of samples then number of params\n\n[1] 10000     4\n\nhead(AedTestFit$samples) # show first few sets of samples\n\nMarkov Chain Monte Carlo (MCMC) output:\nStart = 1 \nEnd = 7 \nThinning interval = 1 \n        T_max    T_min         q sigma.sq\n[1,] 46.81828 15.94044 0.1560609 1.709173\n[2,] 45.92824 15.94044 0.1560609 1.709173\n[3,] 45.92824 15.94044 0.1560609 1.709173\n[4,] 45.92824 15.94044 0.1560609 1.714180\n[5,] 45.92824 15.94044 0.1184306 1.724040\n[6,] 45.92824 13.73609 0.1184306 2.267213\n[7,] 44.76062 11.55605 0.1184306 2.267213\n\n\n Notice that the samples are of type MCMC, which means they’ve been formatted with the coda package (which bayesTPC uses for some of the plotting and diagnostics). Further, by default we take 10000 samples, no burnin, using a random walk sampler.\nBut we may also want to check what model we fit and the priors that were set:\n\nAedTestFit$model_type\n\nNULL\n\nAedTestFit$priors\n\n               q            T_max            T_min         sigma.sq \n       \"dexp(1)\"  \"dunif(25, 60)\" \"dunif(-10, 20)\"        \"dexp(1)\""
  },
  {
    "objectID": "VB_Bayes_activity2B.html#mcmc-diagnostics",
    "href": "VB_Bayes_activity2B.html#mcmc-diagnostics",
    "title": "Introduction to Bayesian Methods",
    "section": "MCMC diagnostics",
    "text": "MCMC diagnostics\nWe’ll show you a few different ways to examine the output. View the summary of parameters (only the first 5 lines, or it will also show you all of your derived quantities):\n\nsummary(AedTestFit$samples)\n\n\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n           Mean      SD  Naive SE Time-series SE\nT_max    39.036 1.06585 0.0106585       0.105245\nT_min     6.765 1.41244 0.0141244       0.122803\nq         0.111 0.01684 0.0001684       0.002075\nsigma.sq 18.214 2.63796 0.0263796       0.073980\n\n2. Quantiles for each variable:\n\n             2.5%     25%     50%     75%   97.5%\nT_max    37.25295 38.3347 38.9559 39.6153 41.3846\nT_min     3.58434  5.9446  6.9135  7.7130  9.1137\nq         0.07896  0.1003  0.1107  0.1213  0.1461\nsigma.sq 13.54818 16.4654 18.0042 19.9085 23.6455\n\n\n We can also assess this visually by plotting the chains of the three main TPC parameters and the standard devation of the normal observation model:\n\npar(mfrow=c(2,2))\ntraceplot(AedTestFit)\n\n\n\n\n\n\n\n\nThese all seem to be mixing alright, although we can see that we need to drop a bit of the burn-in.\nWe can examine the ACF of the chains as well (one for each parameter), similarly to a time series, to again check for autocorrelation within the chain (we want the autocorrelation to be fairly low):\n\ns1&lt;-as.data.frame(AedTestFit$samples)\npar(mfrow=c(2,2))\nfor(i in 1:4) {\n  acf(s1[,i], lag.max=50, main=\"\",\n      ylab = paste(\"ACF: \", names(s1)[i], sep=\"\"))\n}\n\n\n\n\n\n\n\n\nThere is still a bit of autocorrelation, especially for the 3 quadratic parameters, but it isn’t too bad. The chain for \\sigma is mixing best (the ACF falls off the most quickly). We could reduce the autocorrelation even further by thinning the chain (i.e., change the nt parameter to 5 or 10).\nThe last important diagnostic is to compare the prior and posterior distributions. Various packages in R have bespoke functions to do this. bayesTPC includes a built in function that creates posterior/prior overlap plots for all model parameters (note that the priors are smoothed because the algorithm uses kernel smoothing instead of the exact distribution).\n\nppo_plot(AedTestFit)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe prior distribution here is very different from the posterior. These data are highly informative for the parameters of interest and are very unlikely to be influenced much by the prior distribution (although you can always change the priors to check this). However, notice that the posteriors of T_m and T_0 are slightly truncated by their priors."
  },
  {
    "objectID": "VB_Bayes_activity2B.html#visualizing-the-joint-posterior-of-parameters",
    "href": "VB_Bayes_activity2B.html#visualizing-the-joint-posterior-of-parameters",
    "title": "Introduction to Bayesian Methods",
    "section": "Visualizing the joint posterior of parameters",
    "text": "Visualizing the joint posterior of parameters\nNow that we’ve confirmed that things are working well, it’s often useful to also look at the joint distribution of all of your parameters together. Of course, if you have a high dimensional posterior, rendering a 2-D representation can be difficult. Instead, the standard is to examine the pair-wise posterior distribution, for instance as follows:\n\n#ipairs(AedTestFit)\nipairs(AedTestFit)\n\n\n\n\n\n\n\n\nAs you can see, estimates of T_0 and T_m are highly correlated with q– not surprising given the interplay between them in the quadratic function. This correlation is an important feature of the system, and we use the full posterior distribution that includes this correlation when we want to build the corresponding posterior distribution of the behavior of the quadratic function that we’ve fit."
  },
  {
    "objectID": "VB_Bayes_activity2B.html#modifying-the-fitting-routines",
    "href": "VB_Bayes_activity2B.html#modifying-the-fitting-routines",
    "title": "Introduction to Bayesian Methods",
    "section": "Modifying the fitting routines",
    "text": "Modifying the fitting routines\nAs we noted above, the bTPC function has a set of default specifications for multiple components for every type of implemented TPC. Many of these we can change. For example, above we noted that we can see that we need to drop samples for the burn-in. We might also want to change priors, or use an alternative sampler.\n\nAedQuadFit &lt;- b_TPC(data = lf.data.bTPC, ## data\n                    model = 'quadratic', ## model to fit\n                    niter = 11000, ## total iterations\n                    burn = 1000, ## number of burn in samples\n                    samplerType = 'AF_slice', ## slice sampler\n                    priors = list(q = 'dunif(0, .5)', \n                                  sigma.sq = 'dexp(1)') ## priors\n                    ) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n Let’s take a look at the output in this case:\n\nsummary(AedQuadFit$samples)\n\n\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n            Mean      SD  Naive SE Time-series SE\nT_max    38.8635 1.02984 0.0102984      0.0171717\nT_min     6.9431 1.31368 0.0131368      0.0228201\nq         0.1139 0.01728 0.0001728      0.0002788\nsigma.sq 18.3472 2.66898 0.0266898      0.0349062\n\n2. Quantiles for each variable:\n\n             2.5%     25%     50%     75%   97.5%\nT_max    37.15271 38.1332 38.7686 39.4728 41.1759\nT_min     3.96365  6.1694  7.0591  7.8705  9.1318\nq         0.07996  0.1022  0.1133  0.1256  0.1481\nsigma.sq 13.74818 16.4704 18.1355 19.9688 24.1041\n\n\n We again plot the chains of the three main TPC parameters and the standard deviation of the normal observation model:\n\n## plot(lf.fit.mcmc[,c(1,3,4)]) ## default coda plot\npar(mfrow=c(2,2))\ntraceplot(AedQuadFit)\n\n\n\n\n\n\n\n\nThese all seem to be mixing well, better that the first time, although we can see that we need to drop a bit of the burn-in.\nWe again look at ACF of the chains as well (one for each parameter):\n\ns1&lt;-as.data.frame(AedQuadFit$samples)\npar(mfrow=c(2,2))\nfor(i in 1:4) acf(s1[,i], lag.max=50, main=\"\", ylab = paste(\"ACF: \", names(s1)[i], sep=\"\"))\n\n\n\n\n\n\n\n\nNotice this falls off much more quickly – the samples from the slice filter in this case are less autocorrelated than the default random walk (“RW”) filter.\nAnd comparing the new priors to the posteriors:\n\nppo_plot(AedQuadFit, burn = 1000)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s also fit the Briere function to the data, just to see how it does:\n\nAedBriFit &lt;- b_TPC(data = lf.data.bTPC, ## data\n                    model = 'briere', ## model to fit\n                    niter = 11000, ## total iterations\n                    burn = 1000, ## number of burn in samples\n                    samplerType = 'AF_slice', ## slice sampler\n                    priors = list(T_min = \"dunif(5,10)\",\n                                  T_max = \"dunif(18,35)\",\n                                  sigma.sq = 'dexp(1)') ## priors\n                    ) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n\nsummary(AedBriFit$samples)\n\n\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean        SD  Naive SE Time-series SE\nT_max    34.29541 0.1776595 1.777e-03      2.191e-03\nT_min     5.48960 0.4685661 4.686e-03      7.860e-03\nq         0.01913 0.0009885 9.885e-06      1.181e-05\nsigma.sq 24.62955 3.1544841 3.154e-02      4.240e-02\n\n2. Quantiles for each variable:\n\n             2.5%      25%     50%      75%    97.5%\nT_max    34.03217 34.18925 34.2828 34.39527 34.66184\nT_min     5.01366  5.14286  5.3496  5.68883  6.72048\nq         0.01734  0.01846  0.0191  0.01975  0.02124\nsigma.sq 19.01469 22.44509 24.4139 26.61377 31.38610\n\n\nWe again plot the chains of the three main TPC parameters and the standard deviation of the normal observation model:\n\n## plot(lf.fit.mcmc[,c(1,3,4)]) ## default coda plot\npar(mfrow=c(2,2))\ntraceplot(AedBriFit, burn=1000)\n\n\n\n\n\n\n\n\nOverall very good mixing, but we can see our choice of priors wasn’t ideal.\nWe again look at ACF of the chains as well (one for each parameter):\n\ns2&lt;-as.data.frame(AedBriFit$samples[1000:10000,])\npar(mfrow=c(2,2))\nfor(i in 1:4) {\n  acf(s2[,i], lag.max=50, main=\"\",\n      ylab = paste(\"ACF: \", names(s2)[i], sep=\"\"))\n}\n\n\n\n\n\n\n\n\nThis is great! Finally comparing the new priors to the posteriors:\n\nppo_plot(AedBriFit, burn = 1000)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we look at the joint posterior.\n\nipairs(AedBriFit, burn=1000)\n\n\n\n\n\n\n\n\nFinally, what if we wanted to fit a model not included in bayesTPC?\nLet’s look at how the package defines the Briere model.\n\nget_default_model_specification(\"briere\")\n\nbayesTPC Model Specification of Type:\n  briere\n\nModel Formula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nModel Distribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nModel Parameters and Priors:\n  q ~ dexp(1)\n  T_max ~ dunif(25, 60)\n  T_min ~ dunif(0, 20)\n  sigma.sq ~ dexp(1)\n\n\n For our model, we will choose an alternate Briere formula, changing the square root to a cube root.\n\nf_2(T) = \\begin{cases} 0 &\\text{if } T \\leq T_0 \\\\\nq T (T-T_0) \\sqrt[3]{T_m-T} & \\text{if } T_0 &lt; T &lt;T_m \\\\\n0 &\\text{if } T \\geq T_m \\end{cases}  \n\n\nmy_briere_formula &lt;- expression(q * (Temp - T_min) * ((T_max &gt; Temp) * abs(T_max - Temp))^(1/3) * (T_max &gt; Temp) * (Temp &gt; T_min))\n\n Now, we choose the priors we want to sample from. We’ll include a little more flexibility here to ensure the model fits how we want it to.\n\nmy_briere_priors &lt;- c(\n  q = \"dunif(0,1)\",\n  T_max = \"dunif(20,45)\",\n  T_min = \"dunif(-5,10)\")\n\n Since we have no constants we need to add, that’s all the information we need! We can use specify_normal_model() to create a model object we can train.\n\nmy_briere &lt;- specify_normal_model(\"my_briere\", #model name\n                                  parameters = my_briere_priors, #names are parameters, values are priors\n                                  formula = my_briere_formula\n                                  )\n\nModel type 'my_briere' can now be accessed using other bayesTPC functions. Use `reset_models()` to reset back to defaults.\n\n\n Now we can use this model just like any other.\n\nget_formula(\"my_briere\")\n\nexpression(q * (Temp - T_min) * ((T_max &gt; Temp) * abs(T_max - \n    Temp))^(1/3) * (T_max &gt; Temp) * (Temp &gt; T_min))\n\nget_default_priors(\"my_briere\")\n\n             q          T_max          T_min       sigma.sq \n  \"dunif(0,1)\" \"dunif(20,45)\" \"dunif(-5,10)\"      \"dexp(1)\" \n\n\n We can also pass the model object in, instead of just the name. configure_model() returns the BUGS model that will be trained.\n\ncat(configure_model(my_briere))\n\n{\n    for (i in 1:N){\n        m[i] &lt;- ( q * (Temp[i] - T_min) * ((T_max &gt; Temp[i]) * abs(T_max - Temp[i]))^(1/3) * (T_max &gt; Temp[i]) * (Temp[i] &gt; T_min) )\n        Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n    }\n    q ~ dunif(0,1)\n    T_max ~ dunif(20,45)\n    T_min ~ dunif(-5,10)\n    sigma.sq ~ dexp(1)\n}\n\n\n Now, let’s train our Briere model.\n\nAedMyBriFit &lt;- b_TPC(data = lf.data.bTPC, ## data\n                    model = 'my_briere', ## model to fit\n                    niter = 11000, ## total iterations\n                    burn = 1000, ## number of burn in samples\n                    samplerType = 'AF_slice', ## slice sampler\n                    priors = list(sigma.sq = 'dexp(1)') ## priors\n                    )  \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n Finally, we can run the same diagnostics as before.\n\npar(mfrow=c(2,2))\ntraceplot(AedMyBriFit, burn=1000)\n\n\n\n\n\n\n\n\nLooks like the mixing went well again. How about ACF?\n\ns3&lt;-as.data.frame(AedMyBriFit$samples[1000:10000,])\npar(mfrow=c(2,2))\nfor(i in 1:4) {\n  acf(s3[,i], lag.max=50, main=\"\",\n      ylab = paste(\"ACF: \", names(s3)[i], sep=\"\"))\n}\n\n\n\n\n\n\n\n\nGood! Finally, let’s look at our posterior distributions and see how well we fit the data.\n\nppo_plot(AedMyBriFit)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nipairs(AedMyBriFit, burn = 1000)"
  },
  {
    "objectID": "VB_Bayes_activity2B.html#plot-the-fits",
    "href": "VB_Bayes_activity2B.html#plot-the-fits",
    "title": "Introduction to Bayesian Methods",
    "section": "Plot the fits",
    "text": "Plot the fits\nFirst extract the fits/predictions using the bayesTPC_summary function and use the tidyverse to save the model predictions as a tibble. We can then use ggplot to generate a pretty plot of our TPC with prediction bounds\n\n# library(tidyverse)\n# briere_fit &lt;- as_tibble(bayesTPCsummary(AedMyBriFit, plot = FALSE))\n# head(briere_fit)\n\n# Load required packages\nlibrary(bayesTPC)\nlibrary(tidyverse)\n\nsummary_result &lt;- summary(AedMyBriFit)\n\nbayesTPC MCMC of Type:\n  my_briere\n\nFormula:\n  m[i] &lt;- ( q * (Temp - T_min) * ((T_max &gt; Temp) * abs(T_max - Temp))^(1/3) *\n(T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0,1) \n  T_max ~ dunif(20,45) \n  T_min ~ dunif(-5,10) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  34.2754    0.5940    0.5333   17.6303 -126.6395 \n\nMCMC Results:\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n            Mean      SD  Naive SE Time-series SE\nT_max    34.3985 0.23526 0.0023526      0.0033228\nT_min    -0.2150 2.32218 0.0232218      0.0276840\nq         0.5173 0.05824 0.0005824      0.0007021\nsigma.sq 18.7481 2.71916 0.0271916      0.0325633\n\n2. Quantiles for each variable:\n\n            2.5%     25%     50%     75%   97.5%\nT_max    34.0875 34.2301 34.3528 34.5131 34.9839\nT_min    -4.5416 -1.9386 -0.1931  1.4825  4.2315\nq         0.4198  0.4733  0.5133  0.5553  0.6412\nsigma.sq 14.0180 16.8163 18.5158 20.4793 24.5147\n\nbriere_df &lt;- as_tibble(summary_result$statistics, rownames = \"Parameter\")\n\nsummary_result &lt;- summary(AedMyBriFit)\n\nbayesTPC MCMC of Type:\n  my_briere\n\nFormula:\n  m[i] &lt;- ( q * (Temp - T_min) * ((T_max &gt; Temp) * abs(T_max - Temp))^(1/3) *\n(T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0,1) \n  T_max ~ dunif(20,45) \n  T_min ~ dunif(-5,10) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  34.2754    0.5940    0.5333   17.6303 -126.6395 \n\nMCMC Results:\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n            Mean      SD  Naive SE Time-series SE\nT_max    34.3985 0.23526 0.0023526      0.0033228\nT_min    -0.2150 2.32218 0.0232218      0.0276840\nq         0.5173 0.05824 0.0005824      0.0007021\nsigma.sq 18.7481 2.71916 0.0271916      0.0325633\n\n2. Quantiles for each variable:\n\n            2.5%     25%     50%     75%   97.5%\nT_max    34.0875 34.2301 34.3528 34.5131 34.9839\nT_min    -4.5416 -1.9386 -0.1931  1.4825  4.2315\nq         0.4198  0.4733  0.5133  0.5553  0.6412\nsigma.sq 14.0180 16.8163 18.5158 20.4793 24.5147\n\nbriere_fit &lt;- as_tibble(summary_result$statistics, rownames = \"Parameter\")\n\n\nparams &lt;- MAP_estimate(AedMyBriFit)\ntemp_seq &lt;- seq(5, 45, by = 0.2)\n# Define the Brière function\nbriere_model &lt;- function(T, q, T_min, T_max) {\n  out &lt;- q * (T - T_min) * ((T_max &gt; T) * abs(T_max - T))^(1/3)\n  out[(T &lt; T_min) | (T &gt; T_max)] &lt;- 0\n  return(out)\n}\n\n# Apply using your MAP estimates\npred_values &lt;- briere_model(temp_seq, \n                            q = params[\"q\"], \n                            T_min = params[\"T_min\"], \n                            T_max = params[\"T_max\"])\nbriere_fit &lt;- tibble(Temperature = temp_seq,\n                     Prediction = pred_values)\n\nggplot(briere_fit) +\n  geom_line(aes(Temperature, Prediction), linewidth = 0.4) +\n  theme_bw() + \n  geom_point(data = lf.data.comb, aes(Temp, trait),\n             shape = 21, fill = '#C0C0C0', col = '#000000',\n             alpha = 0.8, stroke = 0.5, size = 2) +\n  theme(text = element_text(size = 12),\n        legend.position = 'none',\n        axis.title.y = element_text(size = 12),\n        axis.title.x = element_text(size = 12),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) +\n  scale_y_continuous(expression(plain(paste(\"lifespan (days)\")))) +\n  labs(x = expression(plain(paste(\"Temperature, \", degree, \"C\"))))\n\n\n\n\n\n\n\n\nWe can also use the built in function, posteriorPredTPC(), to plot the median and lower/upper bounds from samples taken from the posterior distribution.\n\nposterior_predictive(AedMyBriFit)\n\nFinally we can plot the fits/predictions. These are the posterior estimates of the fitted lines to the data. Recall that we can take each accepted sample, and plug it into the quadratic equations. This gives us the same number of possible lines as samples. We can then summarize these with the HPD intervals across each temperature. This is especially easy in this case because we’ve already saved these samples as output in our model file:"
  },
  {
    "objectID": "VB_Bayes_activity2B.html#additional-analyses",
    "href": "VB_Bayes_activity2B.html#additional-analyses",
    "title": "Introduction to Bayesian Methods",
    "section": "Additional analyses",
    "text": "Additional analyses\nOnce you have all of these samples, you can do many other things. For example, you can use the which.max() function to find the peak temperature (T_{pk}) for adult lifespan and its value at T_{pk}:\n\nlifespan_Tpk &lt;- briere_fit %&gt;% slice(which.max(Prediction))\nT_pk &lt;- lifespan_Tpk$Temperature\nmax_lifespan &lt;- lifespan_Tpk$Prediction\n\n You can then plot T_{pk} and the trait value at T_{pk}:\n\nggplot(briere_fit) +\n  geom_line(aes(Temperature, Prediction), linewidth = 0.4) +\n  theme_bw() + \n  geom_point(data = lf.data.comb, aes(Temp, trait),\n             shape = 21, fill = '#C0C0C0', col = '#000000',\n             alpha = 0.8, stroke = 0.5, size = 2) +\n  geom_point(data = lifespan_Tpk, aes(Temperature, Prediction),\n             shape = 23, fill = 'yellow', col = '#000000',\n             alpha = 0.8, stroke = 0.5, size = 3) +\n  theme(text = element_text(size = 12),\n        legend.position = 'none',\n        axis.title.y = element_text(size = 12),\n        axis.title.x = element_text(size = 12),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) +\n  scale_y_continuous(expression(plain(paste(\"lifespan (days)\")))) +\n  labs(x = expression(plain(paste(\"Temperature, \", degree, \"C\"))))\n\n\n\n\n\n\n\n\n\nThis suggests that the optimal temperature for adult lifespan in Aedes aegypti is 25.8 degrees Celsius! Can you now figure out how to get the credible intervals for T_{pk} and the trait value at T_{pk}?"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "The bayesTPC package",
    "section": "",
    "text": "The bayesTPC R package is for Bayesian fitting of Thermal Performance Curves (TPCs) to trait responses. The package is built using the nimble language and machinery as the underlying engine for Markov Chain Monte Carlo (MCMC). Our main aims in releasing bayesTPC were to support the adoption of Bayesian approaches in thermal physiology, and to promote TPC fitting that adequately quantifies uncertainty.\nA paper introducing the package was published Methods in Ecology and Evolution. This paper introduces much of the functionality of the package. The version of the package corresponding to the published paper is available on Zenodo. The current development version of the package is available through our github repository."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tutorials for bayesTPC",
    "section": "",
    "text": "This webpage is designed to be an evolving document with up-to-date tutorials on the R package bayesTPC. These tutorials have been developed over a number of years with content by the bayesTPC team. Portions of these materials have appeared else where (such as in a VectorByte Training workshop, an EEID training workshop, and the published paper describing the package). However, we felt that it was important to have a central location where we could aggregate these materials and update them as new functionality is added to the package."
  },
  {
    "objectID": "BT_temp.html",
    "href": "BT_temp.html",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "Source: El Moustaid et al. 2021 Supplement | Original experiment: Lysyk & Danyk 2007\nThis analysis recreates the fecundity thermal performance curve from the Bluetongue virus transmission study, showing how midge reproduction varies with temperature.\n\n\nWe analyze 29 fecundity measurements (eggs per female per day) across 5 temperature groups:\n\n\nTemperature groups:\n\n\n# A tibble: 5 x 2\n      T     n\n  &lt;dbl&gt; &lt;int&gt;\n1    10     6\n2    15     6\n3    20     6\n4    25     7\n5    30     7\n\n\n\nFecundity range: 0.4 to 70 eggs per female per day\n\n\n\n\n\nWe fit a Brière model to capture the temperature-dependent fecundity pattern:\nModel: F(T) = k × T × (T - T_min) × √(T_max - T)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**MAP Estimates:**\n\n\n&lt;U+2022&gt; T_min = 5.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; T_max = 32.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; q = 0.018 \n\n\n&lt;U+2022&gt; sigma.sq = 66.5715 \n\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0, 200) \n  T_max ~ dunif(32, 36) \n  T_min ~ dunif(5, 15) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  32.0051    5.0101    0.0184   66.5715 -249.7617 \n\nMCMC Results:\nIterations = 1:12000\nThinning interval = 1 \nNumber of chains = 4 \nSample size per chain = 12000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean       SD  Naive SE Time-series SE\nT_max    32.28717 0.313422 1.431e-03      6.308e-03\nT_min     5.85043 0.762443 3.480e-03      1.126e-02\nq         0.01857 0.001904 8.690e-06      2.655e-05\nsigma.sq 68.51747 5.743078 2.621e-02      5.614e-02\n\n2. Quantiles for each variable:\n\n             2.5%     25%      50%      75%    97.5%\nT_max    32.00680 32.0761 32.18537 32.38196 33.16290\nT_min     5.02610  5.2674  5.63096  6.21703  7.80807\nq         0.01494  0.0173  0.01853  0.01983  0.02238\nsigma.sq 58.00772 64.5654 68.27074 72.25270 80.47774\n\n\n**Posterior Medians:**\n\n\n&lt;U+2022&gt; Lower limit (T_min):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Upper limit (T_max):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Scaling factor (q):  \n\n\n**Optimal Temperature:**\n\n\n&lt;U+2022&gt; Peak fecundity at:  &lt;U+00B0&gt;C\n\n\n\n\n\n\nThe thermal performance curve reveals critical insights about midge reproduction:\n\n\n\nLower limit (T_min): Below this temperature, midges cannot reproduce\nUpper limit (T_max): Above this temperature, reproduction ceases due to heat stress\n\n\n\n\n\nPeak performance: Maximum fecundity occurs around the midpoint of the thermal range\nTemperature sensitivity: The curve shows how reproduction drops off rapidly at thermal extremes\n\n\n\n\nThese results inform disease transmission models by quantifying how temperature affects vector population growth and disease spread potential."
  },
  {
    "objectID": "BT_temp.html#dataset",
    "href": "BT_temp.html#dataset",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "We analyze 29 fecundity measurements (eggs per female per day) across 5 temperature groups:\n\n\nTemperature groups:\n\n\n# A tibble: 5 x 2\n      T     n\n  &lt;dbl&gt; &lt;int&gt;\n1    10     6\n2    15     6\n3    20     6\n4    25     7\n5    30     7\n\n\n\nFecundity range: 0.4 to 70 eggs per female per day"
  },
  {
    "objectID": "BT_temp.html#thermal-performance-curve",
    "href": "BT_temp.html#thermal-performance-curve",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "We fit a Brière model to capture the temperature-dependent fecundity pattern:\nModel: F(T) = k × T × (T - T_min) × √(T_max - T)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters."
  },
  {
    "objectID": "BT_temp.html#results",
    "href": "BT_temp.html#results",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "**MAP Estimates:**\n\n\n&lt;U+2022&gt; T_min = 5.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; T_max = 32.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; q = 0.018 \n\n\n&lt;U+2022&gt; sigma.sq = 66.5715 \n\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0, 200) \n  T_max ~ dunif(32, 36) \n  T_min ~ dunif(5, 15) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  32.0051    5.0101    0.0184   66.5715 -249.7617 \n\nMCMC Results:\nIterations = 1:12000\nThinning interval = 1 \nNumber of chains = 4 \nSample size per chain = 12000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean       SD  Naive SE Time-series SE\nT_max    32.28717 0.313422 1.431e-03      6.308e-03\nT_min     5.85043 0.762443 3.480e-03      1.126e-02\nq         0.01857 0.001904 8.690e-06      2.655e-05\nsigma.sq 68.51747 5.743078 2.621e-02      5.614e-02\n\n2. Quantiles for each variable:\n\n             2.5%     25%      50%      75%    97.5%\nT_max    32.00680 32.0761 32.18537 32.38196 33.16290\nT_min     5.02610  5.2674  5.63096  6.21703  7.80807\nq         0.01494  0.0173  0.01853  0.01983  0.02238\nsigma.sq 58.00772 64.5654 68.27074 72.25270 80.47774\n\n\n**Posterior Medians:**\n\n\n&lt;U+2022&gt; Lower limit (T_min):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Upper limit (T_max):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Scaling factor (q):  \n\n\n**Optimal Temperature:**\n\n\n&lt;U+2022&gt; Peak fecundity at:  &lt;U+00B0&gt;C"
  },
  {
    "objectID": "BT_temp.html#biological-interpretation",
    "href": "BT_temp.html#biological-interpretation",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "The thermal performance curve reveals critical insights about midge reproduction:\n\n\n\nLower limit (T_min): Below this temperature, midges cannot reproduce\nUpper limit (T_max): Above this temperature, reproduction ceases due to heat stress\n\n\n\n\n\nPeak performance: Maximum fecundity occurs around the midpoint of the thermal range\nTemperature sensitivity: The curve shows how reproduction drops off rapidly at thermal extremes\n\n\n\n\nThese results inform disease transmission models by quantifying how temperature affects vector population growth and disease spread potential."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "This guide will get you fitting thermal performance curves (TPCs) with bayesTPC quickly and efficiently. Whether you’re new to Bayesian methods or an experienced user, we have tutorials designed for your skill level.\n\n\n\n\nFirst, install the required packages:\n\n# Install nimble first\ninstall.packages(\"nimble\")\n\n# Install bayesTPC from GitHub\nremotes::install_github(\"johnwilliamsmithjr/bayesTPC\")\n\n\n\n\n\nlibrary(nimble)\n\nnimble version 1.3.0 is loaded.\nFor more information on NIMBLE and a User Manual,\nplease visit https://R-nimble.org.\n\nNote for advanced users who have written their own MCMC samplers:\n  As of version 0.13.0, NIMBLE's protocol for handling posterior\n  predictive nodes has changed in a way that could affect user-defined\n  samplers in some situations. Please see Section 15.5.1 of the User Manual.\n\n\n\nAttaching package: 'nimble'\n\n\nThe following object is masked from 'package:stats':\n\n    simulate\n\n\nThe following object is masked from 'package:base':\n\n    declare\n\nlibrary(bayesTPC)\n\nbayesTPC requires loading the package NIMBLE to function.\nPlease run 'library(nimble)` before using.\n\n# Load example data\ndata &lt;- read.csv(\"data/AeaegyptiTraitData.csv\")\ndata_list &lt;- list(Trait = data$trait, Temp = data$Temp)\n\n# Quick plot\nplot(data_list$Trait ~ data_list$Temp, ylab = \"Development Rate\", xlab = \"Temperature (°C)\", pch = 16)\n\n\n\n\n\n\n\n\n\n# Choose a model and fit\nset.seed(1)\nfit &lt;- b_TPC(data = data_list, model = \"briere\")\n\nWarning in check_data(data): Unusual (Temp&gt;50) temperature values detected (are\nTemps given in Celcius?)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n# Check results\nprint(fit)\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nParameters:\n\nChain 1:\n            MAP   Mean Median        Priors\nT_max    25.016 28.948 28.192 dunif(25, 60)\nT_min    19.977 12.828 14.216  dunif(0, 20)\nq         0.057  0.010  0.005       dexp(1)\nsigma.sq 60.460 61.131 61.175       dexp(1)\n\nplot(fit, temp_interval = seq(0, 35, length.out = 1000))\n\nWarning in plot.btpc_MCMC(fit, temp_interval = seq(0, 35, length.out = 1000)):\nUsing default title for plots. Either one title or individual titles for each\nplot may be provided.\n\n\n\n\n\n\n\n\n\nThat’s it! You’ve successfully fit a thermal performance curve.\n\n\n\n\n\n\nEEID 2024 Basic Tutorial - Perfect for new users - Dataset: Aedes aegypti mosquito traits (development rate, adult longevity, juvenile survival) - What you’ll learn: Data formatting, model fitting, diagnostics, model comparison - Time: 30-45 minutes - Jump to: Packages | Data setup | Examples | Practice\n\n\n\nEEID 2024 Advanced Tutorial - For experienced users - Dataset: E. coli growth under antibiotics - What you’ll learn: Custom model creation, posterior transformations, advanced analysis - Time: 45-60 minutes - Jump to: Custom models | Fitting | Transformations\n\n\n\nVectorByte Workshop - Interactive activity - Focus: Mosquito trait modeling - Format: Self-contained exercise - Time: 20-30 minutes\n\n\n\n\n\n\n\nQuick Start (above) - 5 minutes\nBasic Tutorial - Complete workflow\nVectorByte Workshop - Hands-on practice\nAdvanced Tutorial - Custom models\n\n\n\n\n\nJump directly to Advanced Tutorial for custom model creation\nCheck Model comparison for WAIC analysis\nExplore Posterior transformations for advanced analysis\n\n\n\n\n\nAll tutorials use real biological datasets:\n\nVecTraits Database: Access thousands of vector trait datasets\nAntibiotic resistance data: E. coli growth under various antibiotics\nMosquito trait data: Development, survival, and longevity data\n\n\n\n\n\n\nTry these adjustments:\n\n# Adjust priors\npriors = list(T_min = \"dunif(-5,10)\", T_max = \"dunif(30,40)\")\n\n# Use different sampler\nsamplerType = \"AF_slice\"\n\n# Add initial values\ninits = list(T_min = 10, T_max = 32)\n\n\n\n\nCompare models using WAIC:\n\nfit1 &lt;- b_TPC(data_list, \"briere\")\nfit2 &lt;- b_TPC(data_list, \"quadratic\")\nbayesTPC::get_WAIC(fit1)\nbayesTPC::get_WAIC(fit2)\n\n\n\n\nCreate your own TPC function:\n\nmy_model &lt;- specify_normal_model(\"my_model\", \n                                parameters = c(q = \"dunif(0,1)\", T_max = \"dunif(30,50)\"),\n                                formula = expression(q * Temp * (T_max - Temp)))\n\n\n\n\n\n\nDiagnostics: See troubleshooting section in Basic Tutorial\nConvergence: Check convergence tips in Advanced Tutorial\nPackage issues: Ensure you’re using nimble version 0.13.2 (see README)\n\n\n\n\nOnce you’re comfortable with the basics, explore: - Different TPC models: get_models() shows all available options - Custom likelihoods: Beyond normal distributions - Model comparison: Using WAIC and other criteria - Real data: Apply to your own research questions\nReady to dive deeper? Start with the Basic Tutorial for a comprehensive workflow!"
  },
  {
    "objectID": "intro.html#quick-start-5-minutes",
    "href": "intro.html#quick-start-5-minutes",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "First, install the required packages:\n\n# Install nimble first\ninstall.packages(\"nimble\")\n\n# Install bayesTPC from GitHub\nremotes::install_github(\"johnwilliamsmithjr/bayesTPC\")\n\n\n\n\n\nlibrary(nimble)\n\nnimble version 1.3.0 is loaded.\nFor more information on NIMBLE and a User Manual,\nplease visit https://R-nimble.org.\n\nNote for advanced users who have written their own MCMC samplers:\n  As of version 0.13.0, NIMBLE's protocol for handling posterior\n  predictive nodes has changed in a way that could affect user-defined\n  samplers in some situations. Please see Section 15.5.1 of the User Manual.\n\n\n\nAttaching package: 'nimble'\n\n\nThe following object is masked from 'package:stats':\n\n    simulate\n\n\nThe following object is masked from 'package:base':\n\n    declare\n\nlibrary(bayesTPC)\n\nbayesTPC requires loading the package NIMBLE to function.\nPlease run 'library(nimble)` before using.\n\n# Load example data\ndata &lt;- read.csv(\"data/AeaegyptiTraitData.csv\")\ndata_list &lt;- list(Trait = data$trait, Temp = data$Temp)\n\n# Quick plot\nplot(data_list$Trait ~ data_list$Temp, ylab = \"Development Rate\", xlab = \"Temperature (°C)\", pch = 16)\n\n\n\n\n\n\n\n\n\n# Choose a model and fit\nset.seed(1)\nfit &lt;- b_TPC(data = data_list, model = \"briere\")\n\nWarning in check_data(data): Unusual (Temp&gt;50) temperature values detected (are\nTemps given in Celcius?)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n# Check results\nprint(fit)\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nParameters:\n\nChain 1:\n            MAP   Mean Median        Priors\nT_max    25.016 28.948 28.192 dunif(25, 60)\nT_min    19.977 12.828 14.216  dunif(0, 20)\nq         0.057  0.010  0.005       dexp(1)\nsigma.sq 60.460 61.131 61.175       dexp(1)\n\nplot(fit, temp_interval = seq(0, 35, length.out = 1000))\n\nWarning in plot.btpc_MCMC(fit, temp_interval = seq(0, 35, length.out = 1000)):\nUsing default title for plots. Either one title or individual titles for each\nplot may be provided.\n\n\n\n\n\n\n\n\n\nThat’s it! You’ve successfully fit a thermal performance curve."
  },
  {
    "objectID": "intro.html#tutorial-series",
    "href": "intro.html#tutorial-series",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "EEID 2024 Basic Tutorial - Perfect for new users - Dataset: Aedes aegypti mosquito traits (development rate, adult longevity, juvenile survival) - What you’ll learn: Data formatting, model fitting, diagnostics, model comparison - Time: 30-45 minutes - Jump to: Packages | Data setup | Examples | Practice\n\n\n\nEEID 2024 Advanced Tutorial - For experienced users - Dataset: E. coli growth under antibiotics - What you’ll learn: Custom model creation, posterior transformations, advanced analysis - Time: 45-60 minutes - Jump to: Custom models | Fitting | Transformations\n\n\n\nVectorByte Workshop - Interactive activity - Focus: Mosquito trait modeling - Format: Self-contained exercise - Time: 20-30 minutes"
  },
  {
    "objectID": "intro.html#learning-paths",
    "href": "intro.html#learning-paths",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "Quick Start (above) - 5 minutes\nBasic Tutorial - Complete workflow\nVectorByte Workshop - Hands-on practice\nAdvanced Tutorial - Custom models\n\n\n\n\n\nJump directly to Advanced Tutorial for custom model creation\nCheck Model comparison for WAIC analysis\nExplore Posterior transformations for advanced analysis"
  },
  {
    "objectID": "intro.html#available-datasets",
    "href": "intro.html#available-datasets",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "All tutorials use real biological datasets:\n\nVecTraits Database: Access thousands of vector trait datasets\nAntibiotic resistance data: E. coli growth under various antibiotics\nMosquito trait data: Development, survival, and longevity data"
  },
  {
    "objectID": "intro.html#common-issues-solutions",
    "href": "intro.html#common-issues-solutions",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "Try these adjustments:\n\n# Adjust priors\npriors = list(T_min = \"dunif(-5,10)\", T_max = \"dunif(30,40)\")\n\n# Use different sampler\nsamplerType = \"AF_slice\"\n\n# Add initial values\ninits = list(T_min = 10, T_max = 32)\n\n\n\n\nCompare models using WAIC:\n\nfit1 &lt;- b_TPC(data_list, \"briere\")\nfit2 &lt;- b_TPC(data_list, \"quadratic\")\nbayesTPC::get_WAIC(fit1)\nbayesTPC::get_WAIC(fit2)\n\n\n\n\nCreate your own TPC function:\n\nmy_model &lt;- specify_normal_model(\"my_model\", \n                                parameters = c(q = \"dunif(0,1)\", T_max = \"dunif(30,50)\"),\n                                formula = expression(q * Temp * (T_max - Temp)))"
  },
  {
    "objectID": "intro.html#need-help",
    "href": "intro.html#need-help",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "Diagnostics: See troubleshooting section in Basic Tutorial\nConvergence: Check convergence tips in Advanced Tutorial\nPackage issues: Ensure you’re using nimble version 0.13.2 (see README)"
  },
  {
    "objectID": "intro.html#whats-next",
    "href": "intro.html#whats-next",
    "title": "Getting Started with bayesTPC",
    "section": "",
    "text": "Once you’re comfortable with the basics, explore: - Different TPC models: get_models() shows all available options - Custom likelihoods: Beyond normal distributions - Model comparison: Using WAIC and other criteria - Real data: Apply to your own research questions\nReady to dive deeper? Start with the Basic Tutorial for a comprehensive workflow!"
  },
  {
    "objectID": "EEID2024_advanced.html",
    "href": "EEID2024_advanced.html",
    "title": "Advanced topics with bayesTPC",
    "section": "",
    "text": "In this practical, we will see how to add a custom functional form for thermal performance curves that is not currently implemented in bayesTPC. We will also see how to process the output from bayesTPC to generate custom plots or get the posterior distribution of model parameters.\nWe’ll start by loading some packages we will need for this section (please make sure you install any that are missing, especially the scales and tidyverse packages, which we’ll need for some custom plots below).\n# Uncomment lines below and run to install packages if missing. \n#install.packages(\"tidyverse\")\n# install.packages(\"scales\")\nset.seed(1234)\n\nlibrary(tidyverse)\nlibrary(nimble)\nlibrary(HDInterval)\nlibrary(MCMCvis)\nlibrary(coda) # makes diagnostic plots\nlibrary(IDPmisc) # makes nice colored pairs plots to look at joint posteriors\nlibrary(matrixStats)\nlibrary(truncnorm)\nlibrary(bayesTPC)\nlibrary(scales)"
  },
  {
    "objectID": "EEID2024_advanced.html#thermal-performance-curves-under-antibiotics",
    "href": "EEID2024_advanced.html#thermal-performance-curves-under-antibiotics",
    "title": "Advanced topics with bayesTPC",
    "section": "Thermal performance curves under antibiotics",
    "text": "Thermal performance curves under antibiotics\nLet’s take a look at a dataset of the temperature-dependence of the growth of the bacterium Escherichia coli in the presence of various antibiotic backgrounds (data originally from this study).\n\nabdata &lt;- read.csv(\"data/ab_data.csv\")\nhead(abdata)\n\n  drug1name drug2name drug1num drug2num  T  t sample          OD\n1       ERY       GEN        4        6 37 24      1 0.368300008\n2       ERY       GEN        4        6 37 24      2 0.404299991\n3       ERY       GEN        4        6 37 24      3 0.423800008\n4       ERY       GEN        4        6 37 24      4 0.427200006\n5       ERY       GEN        4        6 22 24      1 0.004800001\n6       ERY       GEN        4        6 22 24      2 0.005099999\n\n\nThis dataset consists of optical density (OD) values (which are proportional to the number of bacteria) of E. coli cultures after 24 hour growth at various temperatures (T) under fixed concentrations of 12 antibiotics and all their pairwise combinations. There are four replicates per drug/temperature treatment.\nIn this workshop we will focus on comparing how the thermal performance for E. coli growth looks like under four conditions of interest:\n\nno antibiotic\ngentamicin (GEN)\nerythromycin (ERY)\nGEN+ERY (both antibiotics present at the same time)\n\n\n# The data uses \"WT\" to encode \"no drug\".\nnodrug &lt;- subset(abdata, (abdata[\"drug1name\"] == \"WT\") & (abdata[\"drug2name\"] == \"WT\"))\nGEN &lt;- subset(abdata, (abdata[\"drug1name\"] == \"GEN\") & (abdata[\"drug2name\"] == \"WT\"))\nERY &lt;- subset(abdata, (abdata[\"drug1name\"] == \"ERY\") & (abdata[\"drug2name\"] == \"WT\"))\nboth &lt;- subset(abdata, (abdata[\"drug1name\"] == \"ERY\") & (abdata[\"drug2name\"] == \"GEN\"))\n\nLet’s start by plotting the data.\n\npar(mfrow=c(2,2))\nplot(nodrug$T, nodrug$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"No drug\", ylim=c(0, 1))\nplot(GEN$T, GEN$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"GEN\", ylim=c(0, 1))\nplot(ERY$T, ERY$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"ERY\", ylim=c(0, 1))\nplot(both$T, both$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"GEN+ERY\", ylim=c(0, 1))\n\n\n\n\n\n\n\n\nAs might be expected, adding antibiotics to the growth media decreases the number of bacteria. However, they can decrease growth more at some temperatures than others, leading to changes in the shape of the TPC.\nSome of the shapes you get when adding antibiotics do not look like typical TPCs and it could be difficult to fit this data with many common TPC models. In the following section, we show how we can add a new functional form to bayesTPC that can describe these TPCs."
  },
  {
    "objectID": "EEID2024_advanced.html#a-flexible-and-interpretable-model-for-thermal-performance-curves",
    "href": "EEID2024_advanced.html#a-flexible-and-interpretable-model-for-thermal-performance-curves",
    "title": "Advanced topics with bayesTPC",
    "section": "A flexible and interpretable model for thermal performance curves",
    "text": "A flexible and interpretable model for thermal performance curves\nIn this section, we introduce a new functional form for thermal performance curves called flexTPC. This model aims to be both flexible (aiming to describe unimodal curves of any skewness) and interpretable (with all model parameters having a clear biological interpretation).\nA preprint introducing this model and showing its performance in various different datasets will be available soon. In the meantime, here’s a link to the associated GitHub (which will link to the preprint once it’s ready).\nThe equation for the flexTPC model is\n\\[\nr(T) = r_{\\max}\\left[\\left(\\frac{T - T_{\\min}}{\\alpha} \\right)^{\\alpha} \\left(\\frac{T_{\\max} - T}{1 - \\alpha} \\right)^{1-\\alpha}\n\\left(\\frac{1}{T_{\\max} - T_{\\min}} \\right)\n\\right]^\\frac{\\alpha (1 - \\alpha)}{\\beta^2}\n\\]\nwhere\n\n\\(T_{\\min}\\) is the minimum temperature,\n\\(T_{\\max}\\) the maximum temperature,\n\\(r_{\\max}\\) the maximum trait value/performance of the TPC,\n\\(\\alpha \\in [0,1]\\) determines where the optimal temperature \\(T_{\\mathrm{opt}}\\) is relative to \\(T_{\\min}\\) and \\(T_{\\max}\\) through the equation \\[\nT_{\\mathrm{opt}} = \\alpha T_{\\max} + (1 - \\alpha) T_{\\min}\n\\] (where, for example, \\(\\alpha = 0\\) corresponds to \\(T_{\\mathrm{opt}} = T_{\\min}\\), \\(\\alpha = 1\\) corresponds to \\(T_{\\mathrm{opt}} = T_{\\max}\\) and \\(\\alpha = 1/2\\) corresponds to a symmetric TPC where \\(T_{\\mathrm{opt}} = (T_{\\min} + T_{\\max}) / 2\\)), and\n\\(\\beta &gt; 0\\) determines the breadth of the TPC near its peak.\n\nIt may be more intuitive to look at how the predicted TPC changes as we modify each of these parameters. You can change each parameter in flexTPC in the visualization below to see how it affects the shape of the curve. As you can see, flexTPC can describe curves of a wide variety of shapes, as long as they are unimodal (that is, have a single peak).\n\nviewof T_min = Inputs.range(\n  [-5, 20], \n  {value: 10, step: 0.2, label: \"Tmin:\"}\n)\nviewof T_max = Inputs.range(\n  [30, 50], \n  {value: 35, step: 0.2, label: \"Tmax:\"}\n)\n\nviewof r_max = Inputs.range(\n  [0, 1.2], \n  {value: 1, step: 0.1, label: \"rmax:\"}\n)\n\nviewof alpha = Inputs.range(\n  [0, 1], \n  {value: 0.8, step: 0.02, label: \"alpha:\"}\n)\n\nviewof beta = Inputs.range(\n  [0, 1], \n  {value: 0.3, step: 0.02, label: \"beta:\"}\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction incrementalArray(start, end, step) {\n    var arr = [];\n    // convert count to an integer to avoid rounding errors\n    var count = +((end - start) / step).toFixed();\n    for (var j = 0; j &lt;= count; j++) {\n        var i = start + j * step;\n        arr.push(i);\n    }\n    return arr;\n}\n\nfunction flexTPC(x, T_min, T_max, r_max, alpha, beta) {\n  if (x &lt; T_min) {\n  return 0.0\n  }\n  if (x &gt; T_max) {\n  return 0.0\n  }\n  return r_max * Math.exp((alpha * (1.0 - alpha) / beta**2) * (alpha *    Math.log( (x - T_min) / alpha)  + \n      (1.0 - alpha) * Math.log( (T_max - x) / (1.0 - alpha)) -\n      Math.log(T_max - T_min)))\n}\n\nxvals = incrementalArray(-5, 50, 0.1)\nyvals = xvals.map((x) =&gt; flexTPC(x, T_min, T_max, r_max, alpha, beta))\nzip = (a, b) =&gt; a.map((k, i) =&gt; [k, b[i]]);\ndata = zip(xvals, yvals)\n\nPlot.plot({\n  width: 600,\n  height: 400,\n  y: { domain: [-0.01, 1.25] },\n  marks: [\n    Plot.line(\n      data,\n      {\n        strokeWidth: 3,\n        stroke: \"steelblue\",\n        fontSize: 14\n      }\n    ),\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    Plot.axisX({label: \"Temperature [°C]\", fontSize: 14, marginBottom: 40}),\n    Plot.axisY({label: \"trait performance\", fontSize: 14, x: 0 })\n  ]\n})"
  },
  {
    "objectID": "EEID2024_advanced.html#adding-the-flextpc-function-to-bayestpc",
    "href": "EEID2024_advanced.html#adding-the-flextpc-function-to-bayestpc",
    "title": "Advanced topics with bayesTPC",
    "section": "Adding the flexTPC function to bayesTPC",
    "text": "Adding the flexTPC function to bayesTPC\nWe want to add the flexTPC functional form to bayesTPC in order to fit this data. To do this, we need to do the following:\n\nWe need to write down the flexTPC equation in a format that is understood by bayesTPC.\nWe need to set default prior distributions for all parameters in the model. As we will be focusing on the antibiotic dataset presented earlier, we will define the priors we want to use in this case here directly rather than defining default non-restrictive priors.\n\n\nWriting down an expression for the flexTPC functional form\nEvery functional form in bayesTPC needs to be written down as an expression in R. Let’s start by writing down an expression for the flexTPC equation. In order to avoid some numerical issues, we’ll actually write it in a slightly different way than shown in the equation above. It is not important to understand how these two forms are related, but here’s an explanation if you’re curious (you can safely skip this).\n\n## Note: This looks a little different from the equation as written above, but is\n## equivalent to it. It's just written a little differently for numerical stability.\nflexTPC_formula &lt;- expression((T_max &gt; Temp) * (T_min &lt; Temp) * r_max * exp((alpha * (1 - alpha) / beta^2) * (alpha * log( max((Temp - T_min) / alpha, 10^-20)) \n                                                                                    + (1 - alpha) * log(max ((T_max - Temp) / (1 - alpha), 10^-20))\n                                                                                    - log(T_max - T_min)) ) )\n\n\n\nDefining prior distributions\nWe also need to define prior distributions for every parameter in the model. Rather than define default nonrestrictive priors for all parameters, we will define the prior distributions we want to use for the antibiotic data directly.\n\n# Prior distributions.\nflexTPC_priors &lt;- c(\n  r_max = \"dunif(0, 1)\", # Maximum trait value. Chosen because OD values are less than one and because we want to give equal prior probability to all values in the [0, 1] interval.\n  T_max = \"dnorm(46, 1 / 2^2)\", ## Normal prior with mu=46, sigma=2. Assumes 95% prior CI of approximately [42°C, 50°C].\n  T_min = \"dnorm(10, 1 / 5^2)\", ## Normal prior with mu=10, sigma=5. Assumes 95% prior CI of approximately [0°C, 20°C]\n  alpha = \"dunif(0, 1)\", ## Uniform prior in alpha places equal prior probability on T_opt being anywhere in-between T_min and T_max.\n  beta = \"dgamma(0.3^2 / 0.2^2, 0.3 / 0.2^2)\") ## Gamma prior with mean of 0.3 and standard deviation of 0.2. Asssumes 95% prior CI of approx [0.01, 0.99] for beta. Typical TPCs like those that are described by the Briere and quadratic models have values around 0.2 to 0.4.\n\nNow that we have all the ingredients we need, we can define the flexTPC model in bayesTPC.\n\nflexTPC_normal &lt;- specify_normal_model(\"flexTPC_normal\", #model name\n                                  parameters = flexTPC_priors, #names are parameters, values are priors\n                                  formula = flexTPC_formula\n)\n\nModel type 'flexTPC_normal' can now be accessed using other bayesTPC functions. Use `reset_models()` to reset back to defaults.\n\ncat(configure_model(flexTPC_normal))\n\n{\n    for (i in 1:N){\n        m[i] &lt;- ( (T_max &gt; Temp[i]) * (T_min &lt; Temp[i]) * r_max * exp((alpha * (1 - alpha)/beta^2) * (alpha * log(max((Temp[i] - T_min)/alpha, 10^-20)) + (1 - alpha) * log(max((T_max - Temp[i])/(1 - alpha), 10^-20)) - log(T_max - T_min))) )\n        Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n    }\n    r_max ~ dunif(0, 1)\n    T_max ~ dnorm(46, 1 / 2^2)\n    T_min ~ dnorm(10, 1 / 5^2)\n    alpha ~ dunif(0, 1)\n    beta ~ dgamma(0.3^2 / 0.2^2, 0.3 / 0.2^2)\n    sigma.sq ~ dexp(1)\n}\n\n\nFor any model defined in bayesTPC, we can take a look at how the model expression and the default priors are defined. Let’s do this for flexTPC.\n\nget_formula(\"flexTPC_normal\")\n\nexpression((T_max &gt; Temp) * (T_min &lt; Temp) * r_max * exp((alpha * \n    (1 - alpha)/beta^2) * (alpha * log(max((Temp - T_min)/alpha, \n    10^-20)) + (1 - alpha) * log(max((T_max - Temp)/(1 - alpha), \n    10^-20)) - log(T_max - T_min))))\n\nget_default_priors(\"flexTPC_normal\")\n\n                               r_max                                T_max \n                       \"dunif(0, 1)\"                 \"dnorm(46, 1 / 2^2)\" \n                               T_min                                alpha \n                \"dnorm(10, 1 / 5^2)\"                        \"dunif(0, 1)\" \n                                beta                             sigma.sq \n\"dgamma(0.3^2 / 0.2^2, 0.3 / 0.2^2)\"                            \"dexp(1)\" \n\n\nOptional: Try looking at the formula and default priors for another model in bayesTPC such as the Briere model."
  },
  {
    "objectID": "EEID2024_advanced.html#fitting-the-flextpc-model-to-antibiotic-data",
    "href": "EEID2024_advanced.html#fitting-the-flextpc-model-to-antibiotic-data",
    "title": "Advanced topics with bayesTPC",
    "section": "Fitting the flexTPC model to antibiotic data",
    "text": "Fitting the flexTPC model to antibiotic data\nNow let’s get the data in the right shape and fit the flexTPC model to the data of our conditions of interest.\n\nnodrug.data.bTPC&lt;-list(Trait = nodrug$OD, Temp=nodrug$T)\nnodrugFit &lt;- b_TPC(data = nodrug.data.bTPC, ## data\n                     model = 'flexTPC_normal', ## model to fit\n                     niter = 50000, ## total iterations\n                     burn = 10000, ## number of burn in samples\n                     samplerType = 'AF_slice', ## slice sampler\n                     priors = list(sigma.sq = 'dexp(1 / 0.1^2)'), ## priors\n                     thin = 2,\n                     inits = list(\"T_min\"=15, \"T_max\"=46, \"alpha\"=0.8,\n                                  \"beta\"=0.3, \"r_max\"=0.8)\n) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\nGEN.data.bTPC&lt;-list(Trait = GEN$OD, Temp=GEN$T)\nGENFit &lt;- b_TPC(data = GEN.data.bTPC, ## data\n                     model = 'flexTPC_normal', ## model to fit\n                     niter = 50000, ## total iterations\n                     burn = 10000, ## number of burn in samples\n                     samplerType = 'AF_slice', ## slice sampler\n                     priors = list(sigma.sq = 'dexp(1 / 0.1^2)'), ## priors\n                     thin = 2,\n                     inits = list(\"T_min\"=15, \"T_max\"=46, \"alpha\"=0.5,\n                                  \"beta\"=0.7, \"r_max\"=0.5)\n) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\nERY.data.bTPC&lt;-list(Trait = ERY$OD, Temp=ERY$T)\nERYFit &lt;- b_TPC(data = ERY.data.bTPC, ## data\n                     model = 'flexTPC_normal', ## model to fit\n                     niter = 50000, ## total iterations\n                     burn = 10000, ## number of burn in samples\n                     samplerType = 'AF_slice', ## slice sampler\n                     priors = list(sigma.sq = 'dexp(1 / 0.1^2)'), ## priors\n                     thin = 2,\n                     inits = list(\"T_min\"=15, \"T_max\"=46, \"alpha\"=0.8,\n                                  \"beta\"=0.3, \"r_max\"=0.8)\n) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\nboth.data.bTPC&lt;-list(Trait = both$OD, Temp=both$T)\nbothFit &lt;- b_TPC(data = both.data.bTPC, ## data\n                     model = 'flexTPC_normal', ## model to fit\n                     niter = 50000, ## total iterations\n                     burn = 10000, ## number of burn in samples\n                     samplerType = 'AF_slice', ## slice sampler\n                     priors = list(sigma.sq = 'dexp(1 / 0.1^2)'), ## priors\n                     thin = 2,\n                     inits = list(\"T_min\"=15, \"T_max\"=46, \"alpha\"=0.8,\n                                  \"beta\"=0.3, \"r_max\"=0.8)\n) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\nMost of the traceplots look OK, but here is an example of one that doesn’t look great:\n\npar(mfrow=c(3, 2))\ntraceplot(ERYFit, burn=10000)\n\n\n\n\n\n\n\n\nWe can see than not all of our samples look like a “fuzzy caterpillar” (or at least a healthy one). As can be seen in the traceplot for \\(r_{\\max}\\), occasionally the samples seem to get stuck in some regions of the parameter space. This means the MCMC chains may be converging slowly for some parameters.\nThere’s a few things that can help with convergence of the MCMC chains:\n\nTry another sampler.\nTry setting the initial values of the parameters to values that are likely to be near the best fitting values.\nUse stronger prior distributions.\nRun the chains for longer.\n\nThere are also some diagnostics based on running multiple chains (ideally started from different initial values) that can help us evaluate convergence based on how similar the samples from the different chains are to each other. Future versions of bayesTPC will include the ability to run multiple chains and some of these diagnostics.\nIn this tutorial we’re running the chains for 50000 iterations (instead of 10000 as in previous examples) and providing reasonable initial values which improved sampling compared to initial experiments with shorter runs. For final results, we’d probably run the chains even longer to be safe, although it wouldn’t be practical to do this here due to time constraints.\nHowever, most of the parameters show good mixing and the TPCs we get look reasonable when plotted with the data (you can scroll down to the plots a couple sections below). So it’s likely OK to use our samples for the analysis."
  },
  {
    "objectID": "EEID2024_advanced.html#transformations-of-model-parameters",
    "href": "EEID2024_advanced.html#transformations-of-model-parameters",
    "title": "Advanced topics with bayesTPC",
    "section": "Transformations of model parameters",
    "text": "Transformations of model parameters\nBefore proceeding with the analysis, we should probably plot the curves along with the data. However, we will do this a little bit later in this practical, since we want to show how to do this directly from the MCMC samples to see how we can customize our plots.\nWhen using MCMC methods, we obtain samples from the posterior distribution of the parameters in our model from our MCMC chain. For example, let’s take a look at the first few samples from the condition with no antibiotics.\n\nhead(nodrugFit$samples)\n\nMarkov Chain Monte Carlo (MCMC) output:\nStart = 1 \nEnd = 7 \nThinning interval = 1 \n        T_max    T_min     alpha      beta     r_max     sigma.sq\n[1,] 44.10018 16.65901 0.8294594 0.3671241 0.7913612 0.0014466237\n[2,] 44.05463 17.08606 0.8449004 0.3635676 0.7712699 0.0018935016\n[3,] 44.10128 17.68970 0.8109676 0.3974284 0.7873828 0.0018976245\n[4,] 44.11451 17.72193 0.8145201 0.3705644 0.8236235 0.0019121465\n[5,] 44.07358 18.64857 0.8143284 0.3888070 0.8120611 0.0025006970\n[6,] 44.05575 18.21946 0.8370196 0.3896825 0.7752230 0.0020226051\n[7,] 44.02665 19.19668 0.8348606 0.4121252 0.7715732 0.0008952394\n\n\nEach row corresponds to the values of the parameters in one iteration of the chain. Once the MCMC chain has reached convergence, each iteration corresponds to drawing a sample from the posterior distribution.\nWe can plot the posterior distribution for the individual parameters using these samples. For example, we may want to compare the height of the TPCs (which corresponds to parameter \\(r_{\\max}\\)) between the different antibiotic backgrounds. In this data, this would correspond to the maximum optical density (which is proportional to number of bacteria) under the corresponding antibiotic condition at any temperature.\n\npar(mfrow=c(2, 2))\nhist(nodrugFit$samples[, \"r_max\"], main=\"No drug\", xlab=\"r_max\", xlim=c(0,1))\nhist(ERYFit$samples[, \"r_max\"], main=\"ERY\", xlab=\"r_max\", xlim=c(0,1))\nhist(GENFit$samples[, \"r_max\"], main=\"GEN\", xlab=\"r_max\", xlim=c(0,1))\nhist(bothFit$samples[, \"r_max\"], main=\"ERY+GEN\", xlab=\"r_max\", xlim=c(0,1))\n\n\n\n\n\n\n\n\nNow that we know how to extract posterior samples for our model parameters from the MCMC chains, we will see how we can use these samples to obtain posterior samples for other quantities."
  },
  {
    "objectID": "EEID2024_advanced.html#posterior-distribution-of-functions-of-model-parameters",
    "href": "EEID2024_advanced.html#posterior-distribution-of-functions-of-model-parameters",
    "title": "Advanced topics with bayesTPC",
    "section": "Posterior distribution of functions of model parameters",
    "text": "Posterior distribution of functions of model parameters\nWe can also use the MCMC samples to obtain the posterior distribution (and summaries like medians and credible intervals) of any function involving the model parameters. For example, we might be interested in the difference between the maximum growth observed under the conditions with antibiotics present and when there are no antibiotics in the growth media (note: to do this we need to have the same number of samples for all chains we are comparing).\nWe can do this by simply subtracting the \\(r_{\\max}\\) samples for the conditions of interest (antibiotic(s) and no antibiotic). This will give us a sample of the posterior distribution of the difference between these conditions.\n\npar(mfrow=c(2, 2))\nhist(ERYFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], main=\"ERY\", xlab=\"r_max difference\", xlim=c(-1,1))\nhist(GENFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], main=\"GEN\", xlab=\"r_max difference\", xlim=c(-1,1))\nhist( bothFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], main=\"ERY+GEN\", xlab=\"r_max difference\", xlim=c(-1,1))\n\n\n\n\n\n\n\n\nAs before, we can calculate medians and credible intervals for these differences.\n\nprint(\"ERY\")\n\n[1] \"ERY\"\n\nquantile(ERYFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], c(0.025, 0.5, 0.975))\n\n      2.5%        50%      97.5% \n-0.3191889 -0.1518516  0.1622027 \n\nprint(\"GEN\")\n\n[1] \"GEN\"\n\nquantile(GENFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], c(0.025, 0.5, 0.975))\n\n      2.5%        50%      97.5% \n-0.4947349 -0.4454655 -0.3997772 \n\nprint(\"ERY+GEN\")\n\n[1] \"ERY+GEN\"\n\nquantile(bothFit$samples[, \"r_max\"] - nodrugFit$samples[, \"r_max\"], c(0.025, 0.5, 0.975))\n\n       2.5%         50%       97.5% \n-0.35542608 -0.27921821 -0.05925456 \n\n\nOptional exercise: Maybe we are interested in the proportion of maximum growth in the presence of antibiotics relative to no antibiotics (i.e. the quotient of \\(r_\\max\\) values rather than the difference). Could you modify the code to calculate this instead?\n\nPosterior distribution for the optimal temperature\nLet’s try another example. In the flexTPC model we have an explicit equation for the optimal temperature\n\\[ T_{\\mathrm{opt}} = \\alpha T_{\\max} + (1 - \\alpha) T_{\\min} \\]\nUsing this equation, we can also get posterior samples for \\(T_{\\mathrm{opt}}\\) by transforming the posterior samples for \\(T_{\\min}\\), \\(T_{\\max}\\) and \\(\\alpha\\). For example, for the no-antibiotics condition,\n\n# Function to calculate Topt in flexTPC model from Tmin, Tmax and alpha.\nT_opt_fn &lt;- function(Tmin, Tmax, alpha) {\n  return(alpha * Tmax + (1 - alpha) * Tmin)\n}\n\npar(mfrow=c(1, 1))\nT_opt_samples &lt;- apply(nodrugFit$samples, 1, function(x) T_opt_fn(x[['T_min']], x[['T_max']], x[['alpha']]))\nhist(T_opt_samples)\n\n\n\n\n\n\n\n\nWe can then obtain summaries of the posterior distribution of \\(T_{\\mathrm{opt}}\\) such as the mean, median and/or credible intervals.\n\nmean(T_opt_samples)\n\n[1] 39.11627\n\nquantile(T_opt_samples, c(0.025, 0.5, 0.975))\n\n    2.5%      50%    97.5% \n37.81725 39.10823 40.41961 \n\n\n(Optional exercise: Try calculating the posterior distribution for the optimal temperature of the TPC for a different condition where antibiotics are present.)"
  },
  {
    "objectID": "EEID2024_advanced.html#posterior-distribution-of-tpc-values-at-specific-temperatures",
    "href": "EEID2024_advanced.html#posterior-distribution-of-tpc-values-at-specific-temperatures",
    "title": "Advanced topics with bayesTPC",
    "section": "Posterior distribution of TPC values at specific temperatures",
    "text": "Posterior distribution of TPC values at specific temperatures\nWe can follow a similar approach to obtain the posterior distribution of the value of the thermal performance curve at any temperature (or a grid of temperatures). In this case, the transformation of the parameters we want is simply the equation for the flexTPC model itself at the temperature(s) of interest.\nBy calculating the predicted value at a certain temperature for the parameters that are drawn in each row of our MCMC chains we can get samples from the posterior distribution of the curve at that temperature. We can then directly calculate medians and credible intervals to plot the TPCs.\nIt can be useful to calculate these values directly if we want to customize our plots to make them nicer compared to the bayesTPC defaults. Let’s first look at how we can get these posterior samples for a grid of temperatures.\n\n## Grid of temperatures to use to plot the TPCs.\ntemp &lt;- seq(11, 49, 0.1)\n\n# FlexTPC equation. This is equivalent to the equation shown above, although it's written a little differently.\nflexTPC &lt;- function(T, Tmin, Tmax, rmax, alpha, beta) {\n  Tidx &lt;- (T &gt; Tmin) & (T &lt; Tmax)\n  result &lt;- rep(0, length(T))\n  result[Tidx] &lt;- rmax * exp(alpha * (1 - alpha) / beta^2 *(alpha * log((T[Tidx] - Tmin) / alpha ) +\n                             (1 - alpha) * log((Tmax - T[Tidx]) / ( 1 - alpha) )\n                           - log(Tmax - Tmin)))\n  return(result)\n}\n\n## Here we apply the flexTPC equation to the parameter values at each iteration of the MCMC chain,\n## evaluated at each temperature in our grid.\nndcurves &lt;- apply(nodrugFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nGENcurves &lt;- apply(GENFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nERYcurves &lt;- apply(ERYFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nbothcurves &lt;- apply(bothFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\n\nNow we have a posterior sample for the TPC y-axis value at each of the (x-axis) temperature values in our grid. To clarify this, let’s plot a few of these samples.\n(Note: Please make sure you have the scales package, as we’ll need it in order to make partially transparent colors for some of the plots below).\n\npar(mfrow=c(1,1))\nplot(nodrug$T, nodrug$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"No drug\", ylim=c(0, 1), xlim=c(10, 50))\n## We're plotting the curves that correspond to the first 20 samples in the chain (after removing the burnin samples).\nfor(i in 1:20) {\n  lines(temp, ndcurves[ , i], col=alpha('black', 0.2))\n}\n\n\n\n\n\n\n\n\nEach curve we’re plotting corresponds to the flexTPC model when the parameters are fixed at the current iteration of the MCMC chain. With Bayesian methods, rather than fitting a single curve we have a posterior distribution of possible curves that are consistent with the data and priors.\nNow we can plot the medians (or means) and 95% credible interval at each temperature value in our grid for all antibiotic conditions.\n\npar(mfrow=c(2,2))\nplot(nodrug$T, nodrug$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"No drug\", ylim=c(0, 1), xlim=c(10, 50))\n\nlines(temp, apply(ndcurves, 1, median), col='black', lwd=2) # Plot median of curves at each temperature in grid.\npolygon(c(temp, rev(temp)), c(apply(ndcurves, 1, quantile, 0.025),\n                                rev(apply(ndcurves, 1, quantile, 0.975))), \n        col=alpha(\"black\", 0.3), lty=0) # Plot shaded region with 95% credible interval.\n\nplot(GEN$T, GEN$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"GEN\", ylim=c(0, 1), xlim=c(10, 50))\n\nlines(temp, apply(GENcurves, 1, median), col='steelblue', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(GENcurves, 1, quantile, 0.025),\n                                rev(apply(GENcurves, 1, quantile, 0.975))), \n        col=alpha(\"steelblue\", 0.3), lty=0)\n\nplot(ERY$T, ERY$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"ERY\", ylim=c(0, 1), xlim=c(10, 50))\n\nlines(temp, apply(ERYcurves, 1, median), col='darkgreen', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(ERYcurves, 1, quantile, 0.025),\n                                rev(apply(ERYcurves, 1, quantile, 0.975))), \n        col=alpha(\"darkgreen\", 0.3), lty=0)\n\nplot(both$T, both$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"GEN+ERY\", ylim=c(0, 1), xlim=c(10, 50))\n\nlines(temp, apply(bothcurves, 1, median), col='purple', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(bothcurves, 1, quantile, 0.025),\n                                rev(apply(bothcurves, 1, quantile, 0.975))), \n        col=alpha(\"purple\", 0.3), lty=0)\n\n\n\n\n\n\n\n\nHaving the posterior samples of the TPCs allows us more flexibility in how we display the data when compared to the default plots on bayesTPC. For example, we can plot all the fitted TPCs together to more easily compare them.\n\npar(mfrow=c(1,1))\ntemp &lt;- seq(10, 50, 0.1)\nplot(\"\", \"\", xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"All TPCs\", ylim=c(0, 1), xlim=c(10, 50))\nndcurves &lt;- apply(nodrugFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nlines(temp, apply(ndcurves, 1, median), col='black', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(ndcurves, 1, quantile, 0.025),\n                                rev(apply(ndcurves, 1, quantile, 0.975))), \n        col=alpha(\"black\", 0.3), lty=0)\n\nGENcurves &lt;- apply(GENFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nlines(temp, apply(GENcurves, 1, median), col='steelblue', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(GENcurves, 1, quantile, 0.025),\n                                rev(apply(GENcurves, 1, quantile, 0.975))), \n        col=alpha(\"steelblue\", 0.3), lty=0)\n\nERYcurves &lt;- apply(ERYFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nlines(temp, apply(ERYcurves, 1, median), col='darkgreen', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(ERYcurves, 1, quantile, 0.025),\n                                rev(apply(ERYcurves, 1, quantile, 0.975))), \n        col=alpha(\"darkgreen\", 0.3), lty=0)\n\nbothcurves &lt;- apply(bothFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nlines(temp, apply(bothcurves, 1, median), col='purple', lwd=2)\npolygon(c(temp, rev(temp)), c(apply(bothcurves, 1, quantile, 0.025),\n                                rev(apply(bothcurves, 1, quantile, 0.975))), \n        col=alpha(\"purple\", 0.3), lty=0)\n\n\n\n\n\n\n\n\nHere, the curve with no antibiotics is shown in black. We can see that the GEN+ERY (purple) curve looks very similar to the curve with only ERY (green). In both cases, the number of bacteria is reduced more sharply at low temperatures. The TPC for GEN (blue) looks very different, reducing the number of bacteria more sharply at high temperatures.\nNote that we could use the same functional form (the flexTPC equation) for all of these conditions despite their different shapes. Using a flexible model allows us to directly compare the inferred parameters of thermal performance curves that vary in shape like in this example."
  },
  {
    "objectID": "EEID2024_advanced.html#model-comparison",
    "href": "EEID2024_advanced.html#model-comparison",
    "title": "Advanced topics with bayesTPC",
    "section": "Model comparison",
    "text": "Model comparison\nIn this section, we show another example where we compare between different models with bayesTPC using WAIC. We will compare two candidate models for our data:\na) A single TPC model for the data of all of the antibiotic conditions. This corresponds to a null hypothesis that antibiotics do not affect the thermal performance curve (or equivalently, that all the data comes from the same curve).\nb) Separate TPC models for each antibiotic background, as we had before.\nLet’s fit the model that treats all data as coming from the same thermal performance curve.\n\n# Make a single dataset with the data for all antibiotic backgrounds.\nallconds &lt;- bind_rows(nodrug, GEN, ERY, both)\n\n# Fit a flexTPC model to this data.\nallconds.data.bTPC&lt;-list(Trait = allconds$OD, Temp=allconds$T)\nallcondsFit &lt;- b_TPC(data = allconds.data.bTPC, ## data\n                     model = 'flexTPC_normal', ## model to fit\n                     niter = 50000, ## total iterations\n                     burn = 10000, ## number of burn in samples\n                     samplerType = 'AF_slice', ## slice sampler\n                     priors = list(sigma.sq = 'dexp(1 / 0.1^2)'), ## priors\n                     thin=2\n) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\nNow let’s plot the TPC fit of the null-hypothesis model:\n\nplot(allconds$T, allconds$OD, xlab=\"Temperature [°C]\", ylab=\"OD\", main=\"All data together\", ylim=c(0, 1), xlim=c(10, 50))\naccurves &lt;- apply(allcondsFit$samples, 1, function(x) flexTPC(temp, x[['T_min']], x[['T_max']],\n                                                          x[['r_max']], x[['alpha']], x[['beta']]))\nlines(temp, apply(accurves, 1, median), col='black', lwd=2)\n\npolygon(c(temp, rev(temp)), c(apply(accurves, 1, quantile, 0.025),\n                                rev(apply(accurves, 1, quantile, 0.975))), \n        col=alpha(\"black\", 0.3), lty=0)\n\n\n\n\n\n\n\n\nWe can now do model selection through WAIC. First, let’s find the WAIC for the single curve model.\n\nbayesTPC::get_WAIC(allcondsFit)\n\n       WAIC        lppd       pWAIC \n-120.208842   65.203846    5.099425 \n\n\nThis gives us three values: WAIC (the main quantity we’re interested in), and two terms that are used to calculate the WAIC. These are the lppd (which measures how well the model fits the data) and pWAIC (a term that measures model complexity that depends on the number of parameters and how constrained they are by the priors).\nWe can access the WAIC value itself with the following code:\n\nbayesTPC::get_WAIC(allcondsFit)[[\"WAIC\"]]\n\n[1] -120.2088\n\n\nWe can now find the WAICs from the individual curves. WAIC is calculated for each individual data point and added to get the final value. Because of this, we can simply add the WAICs for the individual curves to get a value that we can compare to the one we calculated above for the null model.\n\nnodrugWAIC &lt;- bayesTPC::get_WAIC(nodrugFit)[[\"WAIC\"]] \nERYWAIC &lt;- bayesTPC::get_WAIC(ERYFit)[[\"WAIC\"]]\nGENWAIC &lt;- bayesTPC::get_WAIC(GENFit)[[\"WAIC\"]]  \nbothWAIC &lt;- bayesTPC::get_WAIC(bothFit)[[\"WAIC\"]]\n\nnodrugWAIC + ERYWAIC + GENWAIC + bothWAIC\n\n[1] -395.8602\n\n\nThe WAIC for the individual curves is much lower (more negative) than for the single curve describing all data. Based on this, modeling this data as individual TPCs is preferred compared to having a single curve for all conditions."
  },
  {
    "objectID": "team.html#postdoctoral-researchers",
    "href": "team.html#postdoctoral-researchers",
    "title": "bayesTPC Team",
    "section": "Postdoctoral Researchers",
    "text": "Postdoctoral Researchers\n\nDr. Paul Huxley"
  },
  {
    "objectID": "team.html#graduate-students",
    "href": "team.html#graduate-students",
    "title": "bayesTPC Team",
    "section": "Graduate Students",
    "text": "Graduate Students\n\nDr. John W. Smith, Jr. – Virginia Tech, PhD, Statistics, 2022"
  },
  {
    "objectID": "team.html#undergraduate-student-researchers",
    "href": "team.html#undergraduate-student-researchers",
    "title": "bayesTPC Team",
    "section": "Undergraduate Student Researchers",
    "text": "Undergraduate Student Researchers\n\nSean Sorek\nYusi Yao"
  },
  {
    "objectID": "refit_guide.html",
    "href": "refit_guide.html",
    "title": "Replicating Published Research with bayesTPC",
    "section": "",
    "text": "This guide demonstrates how to use bayesTPC to replicate thermal performance curve analyses from El Moustaid et al. (2021)."
  },
  {
    "objectID": "refit_guide.html#the-paper",
    "href": "refit_guide.html#the-paper",
    "title": "Replicating Published Research with bayesTPC",
    "section": "The Paper",
    "text": "The Paper\nTitle: “Predicting temperature-dependent transmission suitability of bluetongue virus in livestock”\nJournal: Parasites & Vectors (2021)\nDOI: 10.1186/s13071-021-04826-y"
  },
  {
    "objectID": "refit_guide.html#quick-example-figure-3-replication",
    "href": "refit_guide.html#quick-example-figure-3-replication",
    "title": "Replicating Published Research with bayesTPC",
    "section": "Quick Example: Figure 3 Replication",
    "text": "Quick Example: Figure 3 Replication\n\nThe Problem\nThe survival probability f depends on two traits: - μ (mu): Adult mortality rate - ν (nu): Parasite development rate (ν = 1/EIP)\nThe paper compares three functional forms:\n\n# Three formulas for survival probability\nf_dietz &lt;- function(mu, nu) exp(-mu/nu)\nf_gubbins &lt;- function(mu, nu) nu / (nu + mu)\nf_turner &lt;- function(mu, nu) (3*nu / (3*nu + mu))^3\n\n\n\nImplementation\n\npar(mfrow = c(1, 2), mar = c(5, 5, 4, 2))\n\n# Left: mortality vs survival (ν fixed at 0.061)\nmu_range &lt;- seq(0.2, 0.5, length.out = 100)\nnu_fixed &lt;- 0.061\n\nplot(mu_range, f_dietz(mu_range, nu_fixed), type = \"l\", col = \"black\", lwd = 2,\n     xlab = \"Mortality rate μ\", ylab = \"Survival probability f\",\n     main = \"f vs μ (ν = 0.061)\", ylim = c(0, 1))\nlines(mu_range, f_gubbins(mu_range, nu_fixed), col = \"blue\", lwd = 2)\nlines(mu_range, f_turner(mu_range, nu_fixed), col = \"purple\", lwd = 2)\nlegend(\"topright\", legend = c(\"Dietz (1993)\", \"Gubbins et al. (2008)\", \"Turner et al. (2013)\"),\n       col = c(\"black\", \"blue\", \"purple\"), lwd = 2, bty = \"n\")\n\n# Right: parasite development vs survival (μ fixed at 0.15)\nnu_range &lt;- seq(0, 0.7, length.out = 100)\nmu_fixed &lt;- 0.15\n\nplot(nu_range, f_dietz(mu_fixed, nu_range), type = \"l\", col = \"black\", lwd = 2,\n     xlab = \"Parasite development rate ν\", ylab = \"Survival probability f\",\n     main = \"f vs ν (μ = 0.15)\", ylim = c(0, 1))\nlines(nu_range, f_gubbins(mu_fixed, nu_range), col = \"blue\", lwd = 2)\nlines(nu_range, f_turner(mu_fixed, nu_range), col = \"purple\", lwd = 2)\nlegend(\"topright\", legend = c(\"Dietz (1993)\", \"Gubbins et al. (2008)\", \"Turner et al. (2013)\"),\n       col = c(\"black\", \"blue\", \"purple\"), lwd = 2, bty = \"n\")\n\n\n\n\nFigure 3: Latent period survival probability f as a function of mortality rate μ (left) and parasite development rate ν (right)"
  },
  {
    "objectID": "refit_guide.html#main-challenge-appendix-a.4-refitting-with-bayestpc",
    "href": "refit_guide.html#main-challenge-appendix-a.4-refitting-with-bayestpc",
    "title": "Replicating Published Research with bayesTPC",
    "section": "Main Challenge: Appendix A.4 Refitting with bayesTPC",
    "text": "Main Challenge: Appendix A.4 Refitting with bayesTPC\n\nThe Problem\nThe paper’s parameter notation doesn’t match bayesTPC’s expectations:\n\n\n\nPaper Notation\nbayesTPC Expects\n\n\n\n\nTmin, Tmax, k, tau\nT_min, T_max, q, sigma.sq\n\n\n\n\n\nSolution: Prior Translation System\n\n# Load the translation system\nsource(\"projects/btv-refit/R/priors_translate.R\")\n\n# Paper-style priors\npaper_priors &lt;- list(\n  Tmin = list(dist = \"uniform\", min = 0, max = 8),\n  Tmax = list(dist = \"uniform\", min = 30, max = 40),\n  k = list(dist = \"gamma\", shape = 1, rate = 20),\n  tau = list(dist = \"gamma\", shape = 1.5, rate = 0.001)\n)\n\n# Translate to bayesTPC format\nmodel_key &lt;- model_key_of(\"briere\", \"normal\")\npri_trans &lt;- translate_priors_to_bayesTPC(paper_priors, model_key)\n\n\n\nData Processing\n\n# Load and process data from Appendix A.6\nsource(\"projects/btv-refit/R/01_load_tidy.R\")\nbtv &lt;- readr::read_csv(\"projects/btv-refit/outputs/tidy_btv.csv\")\n\nKey transformations: - Convert percentages to probabilities [0,1] - Calculate ν = 1/EIP (development rate) - Handle edge cases (EIP = 0 → ν = 0)\n\n\nModel Fitting\n\n# Run the complete pipeline\nsource(\"projects/btv-refit/R/04_run_all.R\")\n\nMCMC Settings: - Chains: 5 - Iterations: 25,000 - Burn-in: 5,000 - Thinning: 2"
  },
  {
    "objectID": "refit_guide.html#results",
    "href": "refit_guide.html#results",
    "title": "Replicating Published Research with bayesTPC",
    "section": "Results",
    "text": "Results\n\nThermal Performance Curves\n\n\n\n\n\nFitted thermal performance curves for all traits in C. sonorensis\n\n\n\n\n\n\nParameter Estimates\nFor larval survival (p) in C. sonorensis:\n\n\n\nParameter\nMean\nSD\n2.5%\n97.5%\n\n\n\n\nT_max\n30.19\n0.12\n30.03\n30.48\n\n\nT_min\n6.94\n1.03\n4.15\n7.97\n\n\nq\n0.0053\n0.0004\n0.0043\n0.0061\n\n\nσ²\n9.94\n0.10\n9.74\n10.13\n\n\n\nOptimal temperature range: 7-30°C, peak around 25-30°C\n\n\nUncertainty Attribution (Supplement Fig. A.2)\n\n\n\n\n\nRelative width of 95% credible intervals for traits and derived quantities\n\n\n\n\nKey findings: - Development rate (ν): Most uncertain (0.298) - Vector competence (b): Least uncertain (0.227) - Survival (p): Moderate uncertainty (0.266)"
  },
  {
    "objectID": "refit_guide.html#quality-control",
    "href": "refit_guide.html#quality-control",
    "title": "Replicating Published Research with bayesTPC",
    "section": "Quality Control",
    "text": "Quality Control\n\nConvergence Diagnostics\nAll fits achieved: - R-hat &lt; 1.1 for all parameters - Effective sample size &gt; 1000 for all parameters - Parameter constraints satisfied (T_min &lt; T_max, q &gt; 0)\n\n\nData Validation\n\nProbability traits: All values in [0,1]\nRate traits: All values ≥ 0\nTemperature range: Consistent (12-35°C)"
  },
  {
    "objectID": "refit_guide.html#files-and-resources",
    "href": "refit_guide.html#files-and-resources",
    "title": "Replicating Published Research with bayesTPC",
    "section": "Files and Resources",
    "text": "Files and Resources\n\nPipeline Scripts\n\nPrior Translation: projects/btv-refit/R/priors_translate.R\nMain Pipeline: projects/btv-refit/R/04_run_all.R\nSupplement Analysis: projects/btv-refit/R/supplement_fig_a2_robust.R\n\n\n\nOutputs\n\nTrait Results: projects/btv-refit/outputs/traits/\nVisualization Gallery: projects/btv-refit/visualization_gallery.html\nConfiguration: projects/btv-refit/data/priors_tableA2.yaml"
  },
  {
    "objectID": "EEID2024_basic.html",
    "href": "EEID2024_basic.html",
    "title": "Introduction to Bayesian Methods",
    "section": "",
    "text": "This section is focused on using the bayesTPC package to fit TPCs to data using the methods we’ve explored in the Bayesian lectures and the first two activities. Here we won’t be talking much about the implementation, but instead will rely on the bayesTPC package and it’s functions to allow us to specify, fit, and analyze the data."
  },
  {
    "objectID": "EEID2024_basic.html#data-from-vectraits",
    "href": "EEID2024_basic.html#data-from-vectraits",
    "title": "Introduction to Bayesian Methods",
    "section": "Data from VecTraits",
    "text": "Data from VecTraits\nThe data we want to fit is available on the VecTraits database. We can use the helper function included as part of bayesTPC that isdesigned to interact with this database, get_datasets(), along with the appropriate data set id numbers to retrieve and load them into R.\n\n##aedes_data &lt;- get_VB_datasets(577:579) # updated get_datasets to get_VB_datasets\n\naedes_data&lt;-list()\n\naedes_data[[1]]&lt;-read.csv(\"data/VByte_577.csv\")\naedes_data[[2]]&lt;-read.csv(\"data/VByte_578.csv\")\naedes_data[[3]]&lt;-read.csv(\"data/VByte_579.csv\")\n\nWe have downloaded all three datasets. As always, first we have a look at the data (just looking at a few columns, since the VecTraits format is large so it can hold a lot of different types of information):\n\ncols&lt;-c(2,4,5,6,30)\naedes1&lt;-aedes_data[[3]]\nhead(aedes1[,cols])\n\n  DatasetID OriginalTraitName                        OriginalTraitDef\n1       579         longevity individual-level duration of life stage\n2       579         longevity individual-level duration of life stage\n3       579         longevity individual-level duration of life stage\n4       579         longevity individual-level duration of life stage\n5       579         longevity individual-level duration of life stage\n6       579         longevity individual-level duration of life stage\n  OriginalTraitValue Interactor1Temp\n1                 10              22\n2                  9              22\n3                  7              22\n4                 11              22\n5                 10              22\n6                  6              22\n\n\nTrait data need to be in a particular format before being passed into the fitting routine. Specifically, the data must be stored as a list with names Trait for the modeled response and Temp for the corresponding temperature settings (in ^\\circC, as this is necessary for some of the TPC functions). We format the three datasets here:\n\n# development rate\ndev_rate &lt;- list(Trait = 1/aedes_data[[2]]$OriginalTraitValue,\n                 Temp = aedes_data[[2]]$Interactor1Temp)\n\n# adult longevity\nadult_life &lt;- list(Trait = aedes_data[[3]]$OriginalTraitValue,\n                   Temp = aedes_data[[3]]$Interactor1Temp)\n\n# juvenile survival data\njuv_survival &lt;- list(Trait = aedes_data[[1]]$OriginalTraitValue,\n                     Temp = aedes_data[[1]]$Interactor1Temp)\n\nNotice that we follow a convention here treating the development rate as 1/development time. This is a common assumption (although it is formally only valid if we believe that development times are exponentially distributed). Often mathematical models assume exponentially distributed traits, and so this is why the data are modeled in this fashion. We will show this approach here, as it is common, but do not advocate for this in general.\n\n\n\n\n\n\n\n\nFigure 1: Three example datasets from @huxley2022competition: Development Rate, Adult Longevity, and Juvenile Survival. Temperatures for the juvenile survival data are jittered for visibility\n\n\n\n\n\nWe will first go through a case where the default settings give reasonable output out of the box (adult lifespan) in order to show basic functions in action. We then approach a case where the defaults need to be modified (development rate). As part of your independent practice, you can fit data (juvenile survival) where we would use a glm model for the data."
  },
  {
    "objectID": "EEID2024_basic.html#inference-with-default-settings",
    "href": "EEID2024_basic.html#inference-with-default-settings",
    "title": "Introduction to Bayesian Methods",
    "section": "Inference with default settings",
    "text": "Inference with default settings\nOnce we have the data formatted as required by b_TPC(), we can fit each of the datasets with a single call, using the default settings. As we saw in the plot above, adult lifespan are numeric data where a concave down unimodal response is likely appropriate. For adult lifespan, we chose to fit a Briere function with the default specification:\n\nget_default_model_specification(\"briere\")\n\nbayesTPC Model Specification of Type:\n  briere\n\nModel Formula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nModel Distribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nModel Parameters and Priors:\n  q ~ dexp(1)\n  T_max ~ dunif(25, 60)\n  T_min ~ dunif(0, 20)\n  sigma.sq ~ dexp(1)\n\n\nTo fit the model then requires a single line of code with the first argument being the name of the formatted data object and the second being the name of the TPC that we want to use for fitting. By default we take 10000 samples, no burn-in, using a random walk sampler.\nNoted (Jun 28, 2025): Downgraded nimble to v0.13.2 using remotes::install_version() to fix b_TPC() error caused by missing getNimbleOption().\n\nadult_life_fit &lt;- b_TPC(adult_life, \"briere\")\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\nOnce the fitting process has completed (which can take a few minutes), we can have a gander at the fitted model object using print. This command provides details about the model fit, the priors, and some simple summaries of the fitted model.\n\nprint(adult_life_fit)\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nParameters:\n\nChain 1:\n            MAP   Mean Median        Priors\nT_max    34.425 30.627 28.939 dunif(25, 60)\nT_min     0.010  8.930  5.807  dunif(0, 20)\nq         0.005  0.026  0.008       dexp(1)\nsigma.sq 16.867 28.524 35.283       dexp(1)\n\n\nWe can also see what is in the object:\n\nnames(adult_life_fit)\n\n[1] \"samples\"        \"mcmc\"           \"data\"           \"model_spec\"    \n[5] \"priors\"         \"constants\"      \"uncomp_model\"   \"comp_model\"    \n[9] \"MAP_parameters\"\n\n\nMost of what we do relies on the “samples” portion of the object, although bayesTPC has helper functions to reduce the need to interact with these directly in most cases."
  },
  {
    "objectID": "EEID2024_basic.html#mcmc-diagnotic-plots",
    "href": "EEID2024_basic.html#mcmc-diagnotic-plots",
    "title": "Introduction to Bayesian Methods",
    "section": "MCMC Diagnotic Plots",
    "text": "MCMC Diagnotic Plots\nb_TPC() returns an object of class btpc_MCMC which contains (along with model specification information and data) the MCMC samples as an mcmc object from the package coda. As mentioned in the previous portion of the training, it is important to check the MCMC traceplot before using or interpreting a fitted model to ensure the chains have converged. An MCMC traceplot shows each sample for a parameter in the order that the samples were taken. If the model has converged, the traceplot will eventually start varying around a single point, resembling a “fuzzy caterpillar”.\n\npar(mfrow=c(2,2), mar=c(4,3,3,1)+.1)\ntraceplot(adult_life_fit)\n\n\n\n\n\n\n\nFigure 2: Traceplots for the three parameters of the Briere TPC and the observation parameter for model fitted to the Adult Longevity data.\n\n\n\n\n\nWe notice that it takes a while for the chains to converge. Thus we need to specify a burn-in period and only consider samples obtained after the burn-in. For this example, a burn-in of around 3000 should give us a good result. We can re-visualize with this burn-in (by adding burn=3000 as an argument to traceplot):\n\npar(mfrow=c(2,2), mar=c(4,3,3,1)+.1)\nmyburn&lt;-3000\ntraceplot(adult_life_fit, burn=myburn)\n\n\n\n\n\n\n\nFigure 3: Traceplots for the three parameters of the Briere TPC and the observation parameter for model fitted to the Adult Longevity data. Here the burn-in portion of the MCMC chains has been dropped.\n\n\n\n\n\nThis is much better! All of the chains now have the desired “fuzzy caterpillar” look. Typically one would at this point go back to the original fitting function, and specify the burn-in time, along with potentially increasing the total sample size in order to ensure sufficient samples. This approach drops the burnin samples from the returned object. For brevity herewe will simply specify the value of burn as an argument for the remaining plotting functions.\nWe can examine the ACF of the chains as well (one for each parameter), similarly to a time series, to again check for autocorrelation within the chain (we want the autocorrelation to be fairly low):\n\ns1&lt;-as.data.frame(adult_life_fit$samples[myburn:10000,])\npar(mfrow=c(2,2), bty=\"n\", mar=c(4,4,3,1)+.1)\nfor(i in 1:4) {\n  acf(s1[,i], lag.max=50, main=\"\",\n      ylab = paste(\"ACF: \", names(s1)[i], sep=\"\"))\n}\n\n\n\n\n\n\n\n\nThere is still autocorrelation, especially for two of the quadratic parameters. The chain for \\sigma is mixing best (the ACF falls off the most quickly). We could reduce the autocorrelation even further by thinning the chain (i.e., change the nt parameter to 5 or 10), or changing the type of sampler.\nA second important diagnostic step is to compare the marginal priors and posteriors of our model parameters. This enables us to confirm that (unless we’ve purposefully specified an informative prior) that our posterior distributions have been informed by the data. bayesTPC includes a built in function, ppo_plot(), that creates posterior/prior overlap plots for all model parameters (note that the priors are smoothed because the algorithm uses kernel smoothing instead of the exact distribution).\n\npar(mfrow=c(2,2), mar=c(4,3,3,1)+.1)\nppo_plot(adult_life_fit, burn=myburn, legend_position = \"topright\")\n\n\n\n\n\n\n\nFigure 4: Marginal prior/posterior for the three parameters of the Briere TPC and the observation parameter for the model fitted to the Adult Longevity data. Note that the burn-in is dropped for these plots using the burn argument.\n\n\n\n\n\nThe prior distribution here is very different from the posterior. These data are highly informative for the parameters of interest and are very unlikely to be influenced much by the prior distribution (although you can always change the priors to check this). However, notice that the posterior T_0 is slightly truncated by their priors. If priors and posteriors are very similar one should shift the priors, and re-run."
  },
  {
    "objectID": "EEID2024_basic.html#additional-plotting",
    "href": "EEID2024_basic.html#additional-plotting",
    "title": "Introduction to Bayesian Methods",
    "section": "Additional plotting",
    "text": "Additional plotting\nAfter we have established appropriate burn-in values, we can use plot(), posterior_predictive(), and plot_prediction() to examine the fit of the model in two ways. The defaults for the plot() function plots the median and 95% Highest Posterior Density (HPD) interval of the fitted function (i.e., plugging the samples into the TPC function, and calculating the median and HPD interval at all evaluated temperatures). In contrast, the posterior_predictive() function uses simulation to draw points from the posterior predictive distribution, and so it includes both the samples describing the TPC function and the observational model. It then uses these samples to calculate the mean/median and the HPD interval of those simulated points. Both kinds of plots are shown in Figure 5 for comparison.\n\n\nWarning in posterior_predictive(adult_life_fit, temp_interval = Ts, burn =\nmyburn): Taking posterior predictive samples at less than 1000 points may lead\nto innaccurate results.\n\n\nWarning in plot_prediction.btpc_prediction(posterior_predictive(adult_life_fit,\n: Using default title for plots. Either one title or individual titles for each\nplot may be provided.\n\n\n\n\n\n\n\n\nFigure 5: Comparison of the plots produced by the plot() function (LEFT) and the combination of the posterior_predictive(), and plot_prediction() functions (RIGHT). By default both functions would only make plots/predictions within the range of temperatures included in the fitted data. However here we show the use of the temp_interval argument to enable plotting of predictions across a broader temperature range.\n\n\n\n\n\nNote that the two bottom fits show different output. On the left we show the HPD bounds and median of the fitted Briere function, only. On the right, in contrast, shows the bounds and mean/median of the posterior predictive distribution (so it includes the randomness that is part of the truncated normal observation model). Notice that the HPD predictive interval is a bit jagged here. These intervals are generated using sampling from the posterior predictive distribution. Increasing the total number of samples can give smoother bounds in general.\nNow that we’ve confirmed that things are working well, it’s often useful to also look at the joint distribution of all of your parameters together to understand how estimates are related to each other. Of course, if you have a high dimensional posterior, rendering a 2-D representation can be difficult. The standard is to examine the pair-wise posterior distribution. We can do this using the function bayesTPC_ipairs():\nNoted (Jun 26, 2025):  The function `bayesTPC_ipairs() has been renamed to ipairs()\n\nipairs(adult_life_fit, burn=myburn)\n\n\n\n\n\n\n\nFigure 6: Pairwise visualization of the joint posterior distribution of parameters for the three parameters of the Briere TPC and the observation parameter for the model fitted to the Adult Longevity data. Note that the burn-in is dropped for this plot using the burn argument.\n\n\n\n\n\nNotice that there is substantial correlation between q and T_{min} (a.k.a., T_0). This is typical for most TPCs, and is one of the reasons why prior choice can be very important!"
  },
  {
    "objectID": "EEID2024_basic.html#summaries",
    "href": "EEID2024_basic.html#summaries",
    "title": "Introduction to Bayesian Methods",
    "section": "Summaries",
    "text": "Summaries\nIf we are satisfied with the traceplots, fits, and prior/posterior plots, users may want to examine additional summary output (for example to make tables) or to save summaries. Numerical summaries are available through the print() function shown above, but we can see more details using summary().\n\nsummary(adult_life_fit, burn=myburn)\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dexp(1) \n  T_max ~ dunif(25, 60) \n  T_min ~ dunif(0, 20) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n     T_max      T_min          q   sigma.sq   log_prob \n   34.4249     0.0105     0.0048    16.8668 -1925.6408 \n\nMCMC Results:\nIterations = 1:10000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 10000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean       SD  Naive SE Time-series SE\nT_max    30.62707  3.83150 0.0383150       1.459191\nT_min     8.92963  7.75936 0.0775936       4.572044\nq         0.02603  0.04334 0.0004334       0.004937\nsigma.sq 28.52449 11.30917 0.1130917       6.568526\n\n2. Quantiles for each variable:\n\n              2.5%       25%      50%      75%    97.5%\nT_max    26.227349 26.665473 28.93924 34.42287 34.65589\nT_min     0.130033  1.435688  5.80715 18.05060 19.87969\nq         0.004713  0.005112  0.00831  0.04444  0.09058\nsigma.sq 15.288158 16.980482 35.28255 39.32911 43.25610\n\n\nWe may want to store some of the sample statistics for later use. The sample-based Maximum a posteriori (MAP) estimator is calculated and saved as part of our fitting process, and can be obtained directly from the fit object.\n\n# MAP estimator\nadult_life_fit$MAP_parameters |&gt; round(5)\n\n      T_max       T_min           q    sigma.sq    log_prob \n   34.42491     0.01048     0.00482    16.86677 -1925.64076 \n\n\nThe other sample statistics for each parameter can be obtained by saving the summary of the samples in the fitted model object. Then the various statistics may be extracted directly:\n\nestimates &lt;- summary(adult_life_fit$samples)\n\n# Mean\nestimates$statistics[,\"Mean\"]\n\n      T_max       T_min           q    sigma.sq \n30.62707444  8.92962503  0.02602978 28.52449400 \n\n# Median and 95% CI bounds\nestimates$quantiles[,c(\"2.5%\", \"50%\", \"97.5%\")]\n\n                 2.5%          50%       97.5%\nT_max    26.227348520 28.939237979 34.65588797\nT_min     0.130032986  5.807145306 19.87969129\nq         0.004712554  0.008310401  0.09058492\nsigma.sq 15.288158499 35.282551213 43.25609596\n\n\nIf one instead would like the Highest Posterior Density bounds (instead of the quantile based summaries) the HPDinterval function from coda may be used.\n\nHPDinterval(adult_life_fit$samples)\n\n                lower       upper\nT_max    26.187141922 34.59972900\nT_min     0.129196054 19.86801648\nq         0.004601605  0.08134151\nsigma.sq 15.016773127 42.66189156\nattr(,\"Probability\")\n[1] 0.95"
  },
  {
    "objectID": "EEID2024_basic.html#fitting-with-default-settings",
    "href": "EEID2024_basic.html#fitting-with-default-settings",
    "title": "Introduction to Bayesian Methods",
    "section": "Fitting with default settings",
    "text": "Fitting with default settings\nThe default priors chosen in bayesTPC are generally as non-restrictive as possible, which can lead to inappropriate fits when the response trait is very close to zero. In this case it may be necessary to modify the priors. It is also possible that mixing may be poor with the default sampler, and so we may need to update the sampling method. We briefly show these issues using the development rate data as an example. These data are also numeric and we assume, again, a Briere functional response:\n\ndev_rate_fit &lt;- b_TPC(dev_rate, \"briere\")\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\nHowever in this case, although the traceplots look ok (after a burnin) the fits are very poor (Figure 7)\n\n\nWarning in plot.btpc_MCMC(dev_rate_fit, burn = myburn): Using default title for\nplots. Either one title or individual titles for each plot may be provided.\n\n\n\n\n\n\n\n\nFigure 7: Traceplots for the three parameters of the Briere TPC and the observation parameter for model fitted to the juvenile development data. (top 4 panels) with the data (bottom left) and corresponding posterior predictive (bottom right) plots based on these samples. The burn-in portion of the MCMC chains has been dropped.\n\n\n\n\n\nWe can see a bit of what is going on by looking at the marginal prior/posterior plots:\n\npar(mfrow=c(2,2), mar=c(4,3,3,1)+.1)\nppo_plot(dev_rate_fit, burn=myburn, legend_position = \"topright\")\n\n\n\n\n\n\n\nFigure 8: Marginal prior/posterior for the three parameters of the Briere TPC and the observation parameter for the model fitted to the Juvenile development rate data. Note that the burn-in is dropped for these plots using the burn argument.\n\n\n\n\n\nHere the posterior for q is effectively the same as the prior, and both T_{min} and T_{max} are bumping up against the edges of their ranges."
  },
  {
    "objectID": "EEID2024_basic.html#changing-fitting-arguments",
    "href": "EEID2024_basic.html#changing-fitting-arguments",
    "title": "Introduction to Bayesian Methods",
    "section": "Changing Fitting arguments",
    "text": "Changing Fitting arguments\nIn order to try to improve the fitting, we will modify the priors and the sampler. We notice from the plot of the data that the rate seems to increase across the observed range of the data. Thus it is likely that the T_{\\mathrm{max}} parameter is at or above the temperature manipulated in the experiment and T_{\\mathrm{min}} is below. We can pass this information in as new priors through the priors argument as shown. Further, we can switch to a sampler that has a better chance of converging by modifying the samplerType parameter. Here, we use automated factor slice sampling. Although this sampler is often more effective (especially when parameters are highly correlated, as they are for most TPCs), it is slower and so is not used by default. These changes result in much better fits (see Figure 9).\n\ndev_rate_fit2 &lt;- b_TPC(dev_rate, \"briere\",\n                       priors = list(T_min = \"dunif(0,22)\",\n                                     T_max = \"dunif(34,50)\"),\n                       burn=myburn,\n                       samplerType = \"AF_slice\")\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n\n\nWarning in posterior_predictive(dev_rate_fit2, temp_interval = Ts): Taking\nposterior predictive samples at less than 1000 points may lead to innaccurate\nresults.\n\n\nWarning in plot_prediction.btpc_prediction(posterior_predictive(dev_rate_fit2,\n: Using default title for plots. Either one title or individual titles for each\nplot may be provided.\n\n\n\n\n\n\n\n\nFigure 9: Traceplots for the three parameters of the Briere TPC and the observation parameter for the model fitted to the juvenile development data (top 4 panels) with the corresponding summary (bottom left) and posterior predictive (bottom right) plots based on these samples. The burn-in portion of the MCMC chains has been dropped as part of the fitting.\n\n\n\n\n\nThis is much better! The chains mix well, and our predictions now lie along with the data. If you were to plot the autocorrelation you would notice that it falls off much more quickly."
  },
  {
    "objectID": "EEID2024_basic.html#model-selection",
    "href": "EEID2024_basic.html#model-selection",
    "title": "Introduction to Bayesian Methods",
    "section": "Model Selection",
    "text": "Model Selection\nWhat if we didn’t know that the Briere was the preferred model for these development rate data? We can fit with another function, check all of the diagnostics, and then compare via WAIC (Widely Applicable Information Criterion) to choose between them. For the juvenile development rate, let’s try a quadratic. Let’s look at the implementation details:\n\nget_formula(\"quadratic\")\n\nexpression(-1 * q * (Temp - T_min) * (Temp - T_max) * (T_max &gt; \n    Temp) * (Temp &gt; T_min))\n\n\n\nget_default_priors(\"quadratic\")\n\n               q            T_max            T_min         sigma.sq \n       \"dexp(1)\"  \"dunif(25, 60)\" \"dunif(-10, 20)\"        \"dexp(1)\" \n\n\nI will refit using the default priors, except for the prior for q (so you can see an option):\n\ndev_rate_fit_Quad &lt;- b_TPC(data = dev_rate, ## data\n                           model = 'quadratic', ## model to fit\n                           niter = 10000, ## total iterations\n                           burn = 3000, ## number of burn in samples\n                           samplerType = 'AF_slice', ## slice sampler\n                           priors = list(q = 'dexp(1)') ## priors\n                    ) \n\nCreating NIMBLE model:\n - Configuring model.\n\n\n  [Note] safeDeparse: truncating deparse output to 1 line\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n\nsummary(dev_rate_fit_Quad)\n\nbayesTPC MCMC of Type:\n  quadratic\n\nFormula:\n  m[i] &lt;- ( -1 * q * (Temp - T_min) * (Temp - T_max) * (T_max &gt; Temp) * (Temp &gt;\nT_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dexp(1) \n  T_max ~ dunif(25, 60) \n  T_min ~ dunif(-10, 20) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  55.8028   16.1995    0.0004    0.0003 1855.5737 \n\nMCMC Results:\nIterations = 1:7000\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 7000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n              Mean        SD  Naive SE Time-series SE\nT_max    5.596e+01 2.007e+00 2.399e-02      8.266e-02\nT_min    1.619e+01 3.504e-01 4.188e-03      1.345e-02\nq        3.634e-04 3.919e-05 4.685e-07      1.717e-06\nsigma.sq 2.868e-04 1.523e-05 1.821e-07      2.004e-07\n\n2. Quantiles for each variable:\n\n              2.5%       25%       50%       75%     97.5%\nT_max    5.217e+01 5.455e+01 5.589e+01 5.746e+01 5.960e+01\nT_min    1.554e+01 1.594e+01 1.620e+01 1.644e+01 1.688e+01\nq        3.015e-04 3.331e-04 3.606e-04 3.884e-04 4.467e-04\nsigma.sq 2.584e-04 2.760e-04 2.864e-04 2.968e-04 3.185e-04\n\n\nWe again plot the chains of the three main TPC parameters and the standard deviation of the normal observation model:\n\n\nWarning in posterior_predictive(dev_rate_fit_Quad, temp_interval = Ts, burn =\nmyburn): Taking posterior predictive samples at less than 1000 points may lead\nto innaccurate results.\n\n\nWarning in\nplot_prediction.btpc_prediction(posterior_predictive(dev_rate_fit_Quad, : Using\ndefault title for plots. Either one title or individual titles for each plot\nmay be provided.\n\n\n\n\n\n\n\n\nFigure 10: Traceplots for the three parameters of the quadratic TPC and the observation parameter for the model fitted to the juvenile development data (top 4 panels) with the corresponding summary (bottom left) and posterior predictive (bottom right) plots based on these samples. The burn-in portion of the MCMC chains has been dropped.\n\n\n\n\n\nOnce fitted, we want to be able to choose which of these models is best for these data. Although, a priori we would expect the Briere fit to be best development rates, both fits seem visually reasonable. We can extract the the values of the wAIC [@watanabe2009algebraic] to compare the performance of our models using get_WAIC() (which wraps nimble’s getWAIC() function and produces a tidier format). The preferred model will be the one with the lowest wAIC value. Note that because this is based on samples, you want to have the same number of samples in the chains for each of the models you are comparing.\n\nbayesTPC::get_WAIC(dev_rate_fit2)\n\n        WAIC         lppd        pWAIC \n-3731.888925  1870.426197     4.481735 \n\nbayesTPC::get_WAIC(dev_rate_fit_Quad)\n\n        WAIC         lppd        pWAIC \n-3717.300192  1862.630993     3.980897 \n\n\nIn this case the WAIC for the Briere fit is more negative and so is the preferred model."
  },
  {
    "objectID": "EEID2024_basic.html#practice-option-1",
    "href": "EEID2024_basic.html#practice-option-1",
    "title": "Introduction to Bayesian Methods",
    "section": "Practice Option 1",
    "text": "Practice Option 1\nFor the Aedes aegypti life span data, try to fit 3 TPC functional forms (Briere, quadratic, and Stinner) to the data. Use slice sampling for all three of them, and make the chains a bit longer (say 15000 plus the 3000 burnin). Check all of the diagnostics for all models, and plot the fits. Then compare the three models via WAIC. Which one comes out on top."
  },
  {
    "objectID": "EEID2024_basic.html#practice-option-2",
    "href": "EEID2024_basic.html#practice-option-2",
    "title": "Introduction to Bayesian Methods",
    "section": "Practice Option 2",
    "text": "Practice Option 2\nYou can download some other trait data from the VectorByte – VecTraits Databases or use your own data. Write you own analysis as an independent, self-sufficient R script that produces all the plots in a reproducible workflow when sourced. Use the appropriate functional forms for your data."
  },
  {
    "objectID": "EEID2024_basic.html#practice-option-3",
    "href": "EEID2024_basic.html#practice-option-3",
    "title": "Introduction to Bayesian Methods",
    "section": "Practice Option 3",
    "text": "Practice Option 3\nIn addition to the two datasets that we explored here, we downloaded data on juvenile survival. These data are encoded as zeros and ones, and are more appropriately modeled using a Bernoulli/Binomial distribution – that is as GLMs. bayesTPC has implemented two options for fitting these models, either a linear or quadratic:\n\n## Linear:\nget_default_model_specification(\"bernoulli_glm_lin\")\n\nbayesTPC Model Specification of Type:\n  bernoulli_glm_lin\n\nModel Formula:\n  logit(m[i]) &lt;- ( B0 + B1 * Temp )\n\nModel Distribution:\n  Trait[i] ~ dbern(m[i])\n\nModel Parameters and Priors:\n  B0 ~ dunif(-100,100)\n  B1 ~ dunif(-10,10)\n\n\n\n## Quadratic:\nget_default_model_specification(\"bernoulli_glm_quad\")\n\nbayesTPC Model Specification of Type:\n  bernoulli_glm_quad\n\nModel Formula:\n  logit(m[i]) &lt;- ( B0 + B1 * Temp + B2 * (Temp)^2 )\n\nModel Distribution:\n  Trait[i] ~ dbern(m[i])\n\nModel Parameters and Priors:\n  B0 ~ dunif(-100,100)\n  B1 ~ dunif(-10,10)\n  B2 ~ dunif(-1,1)\n\n\nFit the juvenile survival data using both of these models. Note that the slice sampler is typically better for these, and you will likely need a longer chain and more burn-in. Make sure to use the same number of samples/burn-in for both models. Check all the diagnostic plots and plot the data with the fits. Then use WAIC to choose between the two model variants. What do you conclude?"
  },
  {
    "objectID": "materials.html",
    "href": "materials.html",
    "title": "Tutorials",
    "section": "",
    "text": "This page contains comprehensive tutorials that walk you through using bayesTPC for fitting thermal performance curves (TPCs) to biological trait data. These tutorials are designed for different skill levels and use cases.\n\n\nIf you’re new to bayesTPC, start with our Quick Start Guide for a 5-minute introduction, then dive into these detailed tutorials.\n\n\n\n\n\nThese comprehensive tutorials were developed for the 2024 EEID (Ecology and Evolution of Infectious Diseases) workshop and provide complete workflows with real datasets.\n\n\nPerfect for beginners - Learn the full bayesTPC workflow from data preparation to model selection.\n\nTutorial: EEID 2024 Basic\nDataset: Aedes aegypti mosquito trait data (development rate, adult longevity, juvenile survival)\nKey topics: Data formatting, model fitting, diagnostics, model comparison\nJump to sections: Packages, Data setup, TPC models, Example 1, Example 2, Model selection, Practice\n\n\n\n\nFor experienced users - Learn to create custom TPC models and perform advanced analyses.\n\nTutorial: EEID 2024 Advanced\nDataset: E. coli growth under antibiotics\nKey topics: Custom model creation, posterior transformations, model comparison\nJump to sections: Antibiotics overview, flexTPC model, Add flexTPC, Fitting, Transformations, Topt, Posterior at T, Model comparison\n\n\n\n\n\nA focused activity for learning bayesTPC in the context of vector biology.\n\nTutorial: VectorByte Workshop\nDataset: Aedes aegypti trait data\nFocus: Basic trait modeling with mosquito data\n\n\n\n\n\nAll tutorials use real biological datasets:\n\nVecTraits Database: Access thousands of vector trait datasets\nAntibiotic resistance data: E. coli growth under various antibiotics\nMosquito trait data: Development, survival, and longevity data\n\n\n\n\nNew to bayesTPC? Follow this sequence: 1. Quick Start Guide (5 minutes) 2. EEID Basic Tutorial (comprehensive workflow) 3. VectorByte Workshop (hands-on practice) 4. EEID Advanced Tutorial (custom models)\nExperienced user? Jump directly to: - Advanced Tutorial for custom model creation - Model comparison section for WAIC analysis - Posterior transformations for advanced analysis\n\n\n\n\nCheck the Common issues section in the Quick Start Guide\nReview diagnostics and troubleshooting in the Basic Tutorial\nSee convergence tips in the Advanced Tutorial"
  },
  {
    "objectID": "materials.html#getting-started",
    "href": "materials.html#getting-started",
    "title": "Tutorials",
    "section": "",
    "text": "If you’re new to bayesTPC, start with our Quick Start Guide for a 5-minute introduction, then dive into these detailed tutorials."
  },
  {
    "objectID": "materials.html#tutorial-series",
    "href": "materials.html#tutorial-series",
    "title": "Tutorials",
    "section": "",
    "text": "These comprehensive tutorials were developed for the 2024 EEID (Ecology and Evolution of Infectious Diseases) workshop and provide complete workflows with real datasets.\n\n\nPerfect for beginners - Learn the full bayesTPC workflow from data preparation to model selection.\n\nTutorial: EEID 2024 Basic\nDataset: Aedes aegypti mosquito trait data (development rate, adult longevity, juvenile survival)\nKey topics: Data formatting, model fitting, diagnostics, model comparison\nJump to sections: Packages, Data setup, TPC models, Example 1, Example 2, Model selection, Practice\n\n\n\n\nFor experienced users - Learn to create custom TPC models and perform advanced analyses.\n\nTutorial: EEID 2024 Advanced\nDataset: E. coli growth under antibiotics\nKey topics: Custom model creation, posterior transformations, model comparison\nJump to sections: Antibiotics overview, flexTPC model, Add flexTPC, Fitting, Transformations, Topt, Posterior at T, Model comparison\n\n\n\n\n\nA focused activity for learning bayesTPC in the context of vector biology.\n\nTutorial: VectorByte Workshop\nDataset: Aedes aegypti trait data\nFocus: Basic trait modeling with mosquito data"
  },
  {
    "objectID": "materials.html#dataset-resources",
    "href": "materials.html#dataset-resources",
    "title": "Tutorials",
    "section": "",
    "text": "All tutorials use real biological datasets:\n\nVecTraits Database: Access thousands of vector trait datasets\nAntibiotic resistance data: E. coli growth under various antibiotics\nMosquito trait data: Development, survival, and longevity data"
  },
  {
    "objectID": "materials.html#learning-path",
    "href": "materials.html#learning-path",
    "title": "Tutorials",
    "section": "",
    "text": "New to bayesTPC? Follow this sequence: 1. Quick Start Guide (5 minutes) 2. EEID Basic Tutorial (comprehensive workflow) 3. VectorByte Workshop (hands-on practice) 4. EEID Advanced Tutorial (custom models)\nExperienced user? Jump directly to: - Advanced Tutorial for custom model creation - Model comparison section for WAIC analysis - Posterior transformations for advanced analysis"
  },
  {
    "objectID": "materials.html#need-help",
    "href": "materials.html#need-help",
    "title": "Tutorials",
    "section": "",
    "text": "Check the Common issues section in the Quick Start Guide\nReview diagnostics and troubleshooting in the Basic Tutorial\nSee convergence tips in the Advanced Tutorial"
  },
  {
    "objectID": "BT_temp_updated.html",
    "href": "BT_temp_updated.html",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "Source: El Moustaid et al. 2021 Supplement | Original experiment: Lysyk & Danyk 2007\nThis analysis recreates the fecundity thermal performance curve from the Bluetongue virus transmission study, showing how midge reproduction varies with temperature.\n\n\nWe analyze 29 fecundity measurements (eggs per female per day) across 5 temperature groups:\n\n\nTemperature groups:\n\n\n# A tibble: 5 x 2\n      T     n\n  &lt;dbl&gt; &lt;int&gt;\n1    10     6\n2    15     6\n3    20     6\n4    25     7\n5    30     7\n\n\n\nFecundity range: 0.4 to 70 eggs per female per day\n\n\n\n\n\nWe fit a Brière model to capture the temperature-dependent fecundity pattern:\nModel: F(T) = k × T × (T - T_min) × √(T_max - T)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**MAP Estimates:**\n\n\n&lt;U+2022&gt; T_min = 5.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; T_max = 32.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; q = 0.018 \n\n\n&lt;U+2022&gt; sigma.sq = 66.5715 \n\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0, 200) \n  T_max ~ dunif(32, 36) \n  T_min ~ dunif(5, 15) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  32.0051    5.0101    0.0184   66.5715 -249.7617 \n\nMCMC Results:\nIterations = 1:12000\nThinning interval = 1 \nNumber of chains = 4 \nSample size per chain = 12000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean       SD  Naive SE Time-series SE\nT_max    32.28717 0.313422 1.431e-03      6.308e-03\nT_min     5.85043 0.762443 3.480e-03      1.126e-02\nq         0.01857 0.001904 8.690e-06      2.655e-05\nsigma.sq 68.51747 5.743078 2.621e-02      5.614e-02\n\n2. Quantiles for each variable:\n\n             2.5%     25%      50%      75%    97.5%\nT_max    32.00680 32.0761 32.18537 32.38196 33.16290\nT_min     5.02610  5.2674  5.63096  6.21703  7.80807\nq         0.01494  0.0173  0.01853  0.01983  0.02238\nsigma.sq 58.00772 64.5654 68.27074 72.25270 80.47774\n\n\n**Posterior Medians:**\n\n\n&lt;U+2022&gt; Lower limit (T_min):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Upper limit (T_max):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Scaling factor (q):  \n\n\n**Optimal Temperature:**\n\n\n&lt;U+2022&gt; Peak fecundity at:  &lt;U+00B0&gt;C\n\n\n\n\n\n\nThe thermal performance curve reveals critical insights about midge reproduction:\n\n\n\nLower limit (T_min): Below this temperature, midges cannot reproduce\nUpper limit (T_max): Above this temperature, reproduction ceases due to heat stress\n\n\n\n\n\nPeak performance: Maximum fecundity occurs around the midpoint of the thermal range\nTemperature sensitivity: The curve shows how reproduction drops off rapidly at thermal extremes\n\n\n\n\nThese results inform disease transmission models by quantifying how temperature affects vector population growth and disease spread potential."
  },
  {
    "objectID": "BT_temp_updated.html#dataset",
    "href": "BT_temp_updated.html#dataset",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "We analyze 29 fecundity measurements (eggs per female per day) across 5 temperature groups:\n\n\nTemperature groups:\n\n\n# A tibble: 5 x 2\n      T     n\n  &lt;dbl&gt; &lt;int&gt;\n1    10     6\n2    15     6\n3    20     6\n4    25     7\n5    30     7\n\n\n\nFecundity range: 0.4 to 70 eggs per female per day"
  },
  {
    "objectID": "BT_temp_updated.html#thermal-performance-curve",
    "href": "BT_temp_updated.html#thermal-performance-curve",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "We fit a Brière model to capture the temperature-dependent fecundity pattern:\nModel: F(T) = k × T × (T - T_min) × √(T_max - T)\n\n\nCreating NIMBLE model:\n - Configuring model.\n\n\n - Compiling model.\n\nCreating MCMC:\n - Configuring MCMC.\n - Compiling MCMC.\n - Running MCMC.\n\nProgress:\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nConfiguring Output:\n - Finding Max. a Post. parameters."
  },
  {
    "objectID": "BT_temp_updated.html#results",
    "href": "BT_temp_updated.html#results",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "**MAP Estimates:**\n\n\n&lt;U+2022&gt; T_min = 5.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; T_max = 32.01 &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; q = 0.018 \n\n\n&lt;U+2022&gt; sigma.sq = 66.5715 \n\n\nbayesTPC MCMC of Type:\n  briere\n\nFormula:\n  m[i] &lt;- ( q * Temp * (Temp - T_min) * sqrt((T_max &gt; Temp) * abs(T_max - Temp))\n* (T_max &gt; Temp) * (Temp &gt; T_min) )\n\nDistribution:\n  Trait[i] ~ T(dnorm(mean = m[i], tau = 1/sigma.sq), 0, )\n\nPriors:\n  q ~ dunif(0, 200) \n  T_max ~ dunif(32, 36) \n  T_min ~ dunif(5, 15) \n  sigma.sq ~ dexp(1)\n\nMax. A Post. Parameters: \n    T_max     T_min         q  sigma.sq  log_prob \n  32.0051    5.0101    0.0184   66.5715 -249.7617 \n\nMCMC Results:\nIterations = 1:12000\nThinning interval = 1 \nNumber of chains = 4 \nSample size per chain = 12000 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n             Mean       SD  Naive SE Time-series SE\nT_max    32.28717 0.313422 1.431e-03      6.308e-03\nT_min     5.85043 0.762443 3.480e-03      1.126e-02\nq         0.01857 0.001904 8.690e-06      2.655e-05\nsigma.sq 68.51747 5.743078 2.621e-02      5.614e-02\n\n2. Quantiles for each variable:\n\n             2.5%     25%      50%      75%    97.5%\nT_max    32.00680 32.0761 32.18537 32.38196 33.16290\nT_min     5.02610  5.2674  5.63096  6.21703  7.80807\nq         0.01494  0.0173  0.01853  0.01983  0.02238\nsigma.sq 58.00772 64.5654 68.27074 72.25270 80.47774\n\n\n**Posterior Medians:**\n\n\n&lt;U+2022&gt; Lower limit (T_min):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Upper limit (T_max):  &lt;U+00B0&gt;C\n\n\n&lt;U+2022&gt; Scaling factor (q):  \n\n\n**Optimal Temperature:**\n\n\n&lt;U+2022&gt; Peak fecundity at:  &lt;U+00B0&gt;C"
  },
  {
    "objectID": "BT_temp_updated.html#biological-interpretation",
    "href": "BT_temp_updated.html#biological-interpretation",
    "title": "Bluetongue Virus: Midge Fecundity Analysis",
    "section": "",
    "text": "The thermal performance curve reveals critical insights about midge reproduction:\n\n\n\nLower limit (T_min): Below this temperature, midges cannot reproduce\nUpper limit (T_max): Above this temperature, reproduction ceases due to heat stress\n\n\n\n\n\nPeak performance: Maximum fecundity occurs around the midpoint of the thermal range\nTemperature sensitivity: The curve shows how reproduction drops off rapidly at thermal extremes\n\n\n\n\nThese results inform disease transmission models by quantifying how temperature affects vector population growth and disease spread potential."
  }
]